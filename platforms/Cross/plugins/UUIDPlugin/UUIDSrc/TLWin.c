/*------------------------------------------------------------
| TLWin.c
|-------------------------------------------------------------
|
| PURPOSE: To provide general window functions.
|
| HISTORY: 01.08.97
------------------------------------------------------------*/

#include "TLTarget.h"


#ifdef FOR_MACOS

#include <stdio.h>
#include <stdlib.h>
#include <fp.h>

#include <Traps.h>       // _DrawControls */
#include <Windows.h>

#include "TLTypes.h"
#include "TLBytes.h"
#include "TLAscii.h"
#include "TLStrings.h"
#include "TLBuf.h"
#include "TLMemHM.h"
#include "TLStacks.h"
#include "TLParse.h"
#include "TLList.h"
#include "TLWin.h"
#include "TLModes.h"
#include "TLByteBuffer.h"
#include "TLFile.h"
#include "TLNumber.h"  
#include "TLMacOSMem.h"
#include "TLDialog.h"
#include "TLMenu.h"
#include "TLCursor.h"
#include "TLDyString.h"


List*   TheWindowList;
                // The list of the currently open windows.
                // The data address field of each item holds
                // the address of a dynamically allocated
                // 'Window' record.  The windows are ordered 
                // from front to back, so the first window
                // is front-most.

Window* TheWindow;
                // The current active, front-most window.
 
List*   TheGraphicsWindowList;
                // The list of the currently open graphics
                // window records.

/*------------------------------------------------------------
| MoveWindowToFront
|-------------------------------------------------------------
|
| PURPOSE: To make the given window front-most if it isn't
|          already.
|
| DESCRIPTION: "Unhighlights the previously active window,
| brings the given window to the front of all windows, 
| highlights the window and generates appropriate activate
| events." p. I-284 of IM.
|
| The procedure also sets 'TheWindow', the reference to the
| current active window.
|
| EXAMPLE:  MoveWindowToFront(W);
|
| NOTE:  
|
| ASSUMES: The given window is registered in the window list.
|
| HISTORY: 09.07.98 
|          09.19.98 Added 'SelectWindow'.
|          09.25.98 Added 'TheWindow'.
|          09.27.98 Maded OS-specific promotion conditional.
------------------------------------------------------------*/
void
MoveWindowToFront( Window* W )
{
    // If the window is already front-most.
    if( W == TheWindow )
    {
        // Then no change is needed.
        return;
    }
    
    // Move the window to the first position in the window
    // list.
    MoveItemToFirst( TheWindowList, W->MyItem );
    
    // Set the reference to the current window.
    TheWindow = W;

    // If the OS-specific window is not already frontmost.
    if( W->Wos != FrontWindow() )
    {
        // Change the OS-specific window list too.
        SelectWindow( W->Wos );
        
        // Process the events generated by the window activation.
        ProcessPendingEvents();
    }
}       
    
/*------------------------------------------------------------
| DeleteGenericWindow
|-------------------------------------------------------------
|
| PURPOSE: To deallocate OS-generic windows.
|
| DESCRIPTION: Deletes only subordinate data concerned with
| the OS-generic window itself and the OS-specific window
| if any.
|
| Doesn't delete the content of the window such as text being 
| edited.  
|
| The concept here is that a window is concerned with viewing 
| the data from a certain aspect but there may be more than
| one aspect so the data shouldn't be discarded when the 
| window is.  
|
| Each application will be responsible for discarding it's 
| own data before this procedure is called.
|
| EXAMPLE:  DeleteGenericWindow( W );
|
| NOTE:  
|
| ASSUMES: 
|
| HISTORY: 09.06.98 
|          09.26.98 Moved removal of window from main list
|                   to the end of this procedure to avoid
|                   conflict with 'HideGenericWindow'.
|          09.27.98 Pulled out hiding before deletion and 
|                   added promotion of second window.
|          01.01.99 Fixed deletion of path string.
------------------------------------------------------------*/
void
DeleteGenericWindow( Window* W )
{
    Window* SecondWindow;
    
    // Assume there is no second window needing promotion
    // until proven.
    SecondWindow = 0;

    // If the window is front-most.
    if( W == TheWindow )
    {
        // If there is a second window.
        if( TheWindowList->ItemCount > 1 )
        {
            // Save the identity of the second window.
            SecondWindow = (Window*) 
                W->MyItem->NextItem->DataAddress;
        }
    }
    
    // If there is an OS-specific window record.
    if( W->Wos )
    {
        // If the window is a dialog.
        if( W->IsDialog )
        {
            // Then close the window.
            DeleteDialog( (DialogPtr) TheWindow->Wos );
        }
        else // Not a dialog window.
        {
            // Deallocate the scroll bar controls.
            KillControls( W->Wos );
        
            // Deallocate the OS-specific window record.
            DisposeWindow( W->Wos );
        }
    }
    
    // If the window has a title.
    if( W->Title )
    {
        // Free the title string.
        free( W->Title );
    }
    
    // If the window has a file path.
    if( W->Path )
    {
        // Free the path string.
        free( W->Path );
    }
    
    // If the window has controls.
    if( W->Controls )
    {
        // Make the control list the current list.
        ReferToList( W->Controls );
        
        // For each control in the list.
        while( TheItem )
        {
            // Delete the control record.
//TL Later  DeleteControl( (Control*) TheDataAddress );
            
            ToNextItem();
        }
        
        // Revert to the prior current list.
        RevertToList();
        
        // Delete the control list itself.
        DeleteList( W->Controls );
    }
    
    // Remove the window from the master list.
    DeleteFirstReferenceToData( TheWindowList, (u8*) W );
    
    // Free the window record memory.
    free( W );
    
    // If there is a second window needing promotion.
    if( SecondWindow && SecondWindow != TheWindow )
    {
        // Make the second item front-most.
        MoveWindowToFront( SecondWindow );
    }
}

/*------------------------------------------------------------
| FindFrontMostEditableWindow
|-------------------------------------------------------------
|
| PURPOSE: To find the window record of the front-most 
|          editable window.
|
| DESCRIPTION: Searches the list of all windows for the first
| window that contains editable data.
|
| Returns 0 if no editable window was found.
|
| EXAMPLE:  W = FindFrontMostEditableWindow();
|
| NOTE:  
|
| ASSUMES: 
|
| HISTORY: 09.12.98 From 'FindFrontMostTextWindow()'.
------------------------------------------------------------*/
Window*
FindFrontMostEditableWindow()
{
    Window* W;
    
    // Set current list to be the list of all windows.
    ReferToList( TheWindowList );
    
    // Search the list from front-most to back-most.
    while( TheItem )
    {
        // Refer to the data of the item as a window record.
        W = (Window*) TheDataAddress;
        
        // If the window has editable data.
        if( W->IsEditable )
        {
            // Revert to the prior current list.
            RevertToList();
            
            // Return the window record.
            return( W );
        }
        
        // Advance to the next deeper window in the list.
        ToNextItem();
    }
    
    // Revert to the prior current list.
    RevertToList();
    
    // Return zero to show that no window was found.
    return( 0 );
}

/*------------------------------------------------------------
| FindFrontMostTextWindow
|-------------------------------------------------------------
|
| PURPOSE: To find the window record of the front-most text
|          window.
|
| DESCRIPTION: Searches the list of all windows for the first
| window that contains text.
|
| Returns 0 if no window with text was found.
|
| EXAMPLE:  W = FindFrontMostTextWindow();
|
| NOTE:  
|
| ASSUMES: 
|
| HISTORY: 09.07.98 
------------------------------------------------------------*/
Window*
FindFrontMostTextWindow()
{
    Window* W;
    
    // Set current list to be the list of all windows.
    ReferToList( TheWindowList );
    
    // Search the list from front-most to back-most.
    while( TheItem )
    {
        // Refer to the data of the item as a window record.
        W = (Window*) TheDataAddress;
        
        // If the window has text.
        if( W->IsText )
        {
            // Revert to the prior current list.
            RevertToList();
            
            // Return the window record.
            return( W );
        }
        
        // Advance to the next deeper window in the list.
        ToNextItem();
    }
    
    // Revert to the prior current list.
    RevertToList();
    
    // Return zero to show that no text window was found.
    return( 0 );
}

/*------------------------------------------------------------
| FindOSGenericWindow
|-------------------------------------------------------------
|
| PURPOSE: To find the OS-general window record that refers to 
|          a given OS-specific window.
|
| DESCRIPTION: Searches the list of all windows for the first
| window that refers to the given window.
|
| Returns 0 if no matching window was found.
|
| EXAMPLE:  W = FindOSGenericWindow();
|
| NOTE:  
|
| ASSUMES: 
|
| HISTORY: 09.11.98 
------------------------------------------------------------*/
Window*
FindOSGenericWindow( WindowPtr Wos )
{
    Window* W;
    
    // Set current list to be the list of all windows.
    ReferToList( TheWindowList );
    
    // Search the list from front-most to back-most.
    while( TheItem )
    {
        // Refer to the data of the item as a window record.
        W = (Window*) TheDataAddress;
        
        // If the window refers to the given window.
        if( W->Wos == Wos )
        {
            // Revert to the prior current list.
            RevertToList();
            
            // Return the window record.
            return( W );
        }
        
        // Advance to the next deeper window in the list.
        ToNextItem();
    }
    
    // Revert to the prior current list.
    RevertToList();
    
    // Return zero to show that no matching window was found.
    return( 0 );
}

/*------------------------------------------------------------
| FindWindowForFile
|-------------------------------------------------------------
|
| PURPOSE: To find the window associated with a given file.
|
| DESCRIPTION: Searches the list of all windows and returns 
| the window for the file or 0 if not found.
|
| EXAMPLE:  
|
| NOTE: 
|
| ASSUMES: 
|
| HISTORY: 09.11.98 From 'FindFileInTheTextWindowList' and
|                   'FindOSGenericWindow'.
------------------------------------------------------------*/
Window*
FindWindowForFile( 
    s8* FilePath, // Full file path in C-string format.
    s16 AVolRef ) // Volume reference number for the file.
{
    Window* W;
    
    // Set current list to be the list of all windows.
    ReferToList( TheWindowList );
    
    // Search the list from front-most to back-most.
    while( TheItem )
    {
        // Refer to the data of the item as a window record.
        W = (Window*) TheDataAddress;
        
        // If there is a file associated with the window.
        if( W->IsFile )
        {
            // If the volume reference numbers match.
            if( W->VolRef == AVolRef )
            {
                // If the file path names match.
                if( CompareStringsCaseSensitive( W->Path, FilePath ) )
                {
                    // Revert to the prior current list.
                    RevertToList();
                    
                    // Return the window record.
                    return( W );
                }
            }
        }
        
        // Advance to the next deeper window in the list.
        ToNextItem();
    }
    
    // Revert to the prior current list.
    RevertToList();
    
    // Return zero to show that no matching window was found.
    return( 0 );
}

/*------------------------------------------------------------
| HideGenericWindow
|-------------------------------------------------------------
|
| PURPOSE: To make the given window invisible.
|
| DESCRIPTION: If the window is already invisible this 
| procedure has no effect.
|
| If the given window is the front-most window and there's a
| window behind it, the given window will be deactivated and
| the next window will be activated via events.
|
| EXAMPLE:    HideGenericWindow( W );  
|
| NOTES:   
|
| ASSUMES:  
|
| HISTORY: 09.19.98
|          09.26.98 Added check for another window before
|                   attempting to promote one.
------------------------------------------------------------*/
void
HideGenericWindow( Window* W )
{
    // If the window is visible.
    if( W->IsVisible )
    {
        // If the window is front-most.
        if( W == TheWindow )
        {
            // If there is a second window.
            if( TheWindowList->ItemCount > 1 )
            {
                // Make the second item front-most.
                MoveWindowToFront( (Window*) 
                    W->MyItem->NextItem->DataAddress );
            }
        }
        
        // Call the os-specific window hiding routine.
        
        // Erase the window and redraw what was behind the
        // window.
        HideWindow( W->Wos ); 
        
        // Process the events generated by the HideWindow.
        ProcessPendingEvents();
        
        // Mark the window as invisible.
        W->IsVisible = 0;
    }  
}

/*------------------------------------------------------------
| IsAnyEditableWindows
|-------------------------------------------------------------
|
| PURPOSE: To test if any editable windows exist.
|
| DESCRIPTION: Returns 1 if at least one editable window
| exists.
|
| EXAMPLE:  if( IsAnyEditableWindows() )
|
| NOTE:  
|
| ASSUMES: 
|
| HISTORY: 09.06.98 
------------------------------------------------------------*/
u32     
IsAnyEditableWindows()
{
    Window* W;
    
    // Set current list to be the list of all windows.
    ReferToList( TheWindowList );
    
    // Search the list from front-most to back-most.
    while( TheItem )
    {
        // Refer to the data of the item as a window record.
        W = (Window*) TheDataAddress;
        
        // If the window has text.
        if( W->IsText )
        {
            // Revert to the prior current list.
            RevertToList();
            
            // Say that an editable window exists.
            return( 1 );
        }
        
        // Advance to the next deeper window in the list.
        ToNextItem();
    }
    
    // Revert to the prior current list.
    RevertToList();
    
    // Return false to show that no text window was found.
    return( 0 );
}   


/*------------------------------------------------------------
| MakeGenericWindow
|-------------------------------------------------------------
|
| PURPOSE: To allocate a new os-generic window record.
|
| DESCRIPTION: Makes an empty window record and adds it to
| the list of all windows.
|
| EXAMPLE:  W = MakeGenericWindow();
|
| NOTE: Use 'DeleteGenericWindow()' to deallocate window records and
|       their subordinate parts.
|
| ASSUMES: 
|
| HISTORY: 09.06.98 
------------------------------------------------------------*/
Window*
MakeGenericWindow()
{
    Window* W;
    
    // Allocate the window record.
    W = (Window*) malloc( sizeof( Window ) );
    
    // Fill the record with all zeros.
    FillBytes( (u8*) W, sizeof( Window ), 0 );

    // Add the window to the master list, behind all other
    // windows.
    W->MyItem = InsertDataLastInList( TheWindowList, (u8*) W );
    
    // Return the window.
    return( W );
}
 
/*------------------------------------------------------------
| SetPathOfGenericWindow
|-------------------------------------------------------------
|
| PURPOSE: To set the path of an OS-generic window.
|
| DESCRIPTION: Replaces any existing path with a copy of
| the given path string. 
|
| EXAMPLE:   SetPathOfGenericWindow( MyWindow, "A:New" );
|
| NOTE:  
|
| ASSUMES: 
|
| HISTORY: 09.27.98 
------------------------------------------------------------*/
void
SetPathOfGenericWindow( Window* W, s8* NewPath )
{
    // If the window has a path.
    if( W->Path )
    {
        // Free it.
        free( W->Path );
    }
    
    // Duplicate the given title string.
    W->Path = DuplicateString( NewPath );
}

/*------------------------------------------------------------
| SetTitleOfGenericWindow
|-------------------------------------------------------------
|
| PURPOSE: To set the title of an OS-generic window and the
|          title of any associated OS-specific window.
|
| DESCRIPTION: Replaces any existing title with a copy of
| the given title string.  If there is an OS-specific window
| associated with the window then the title of that window
| is also set to the given title.
|
| EXAMPLE:   SetTitleOfGenericWindow( MyWindow, "New" );
|
| NOTE:  
|
| ASSUMES: 
|
| HISTORY: 09.27.98 
------------------------------------------------------------*/
void
SetTitleOfGenericWindow( Window* W, s8* NewTitle )
{
    Str255  AFileName;
    
    // If the window has an existing title.
    if( W->Title )
    {
        // Free it.
        free( W->Title );
    }
    
    // Duplicate the given title string.
    W->Title = DuplicateString( NewTitle );
    
    // If there is an OS-specific window.
    if( W->Wos )
    {
        // Translate the string to Pascal format.
        CopyCToPascalString( NewTitle, (s8*) AFileName );
        
        // Change the window title in the OS-specific window.
        SetWTitle( W->Wos, AFileName );
    }
}

/*------------------------------------------------------------
| SetUpTheWindowSystem
|-------------------------------------------------------------
|
| PURPOSE: To set up the window system for use.
|
| DESCRIPTION: 
|
| EXAMPLE:  SetUpTheWindowSystem();
|
| NOTE: This procedure must be executed prior to running
|       any other procedure in the window system.
|
| ASSUMES: 
|
| HISTORY: 01.08.97
|          09.06.98 Added 'TheWindowList'.
|          09.27.98 Pulled out 'TheTextWindowList'.
------------------------------------------------------------*/
void
SetUpTheWindowSystem()
{
    // Make a list to hold all open windows.
    TheWindowList = MakeList();
    
    // Make a list to hold window records of all open windows
    // that are held in the 'WindowMenu' list, in the same
    // order as the 'WindowMenu' list.
    TheWindowMenuList = MakeList();
}

/*------------------------------------------------------------
| ShowGenericWindow
|-------------------------------------------------------------
|
| PURPOSE: To show the given window but don't change the
|          front-to-back ordering.
|
| DESCRIPTION: If the window is already visible this procedure
| has no effect.
|
| EXAMPLE:    ShowGenericWindow( W );  
|
| NOTES:   
|
| ASSUMES:  
|
| HISTORY: 09.19.98
------------------------------------------------------------*/
void
ShowGenericWindow( Window* W )
{
    // If the window is invisible.
    if( W->IsVisible == 0 )
    {
        // Call the os-specific window drawing routine.
        
        // If the front-most window is invisible an activate
        // event will be generated to force the window from
        // inactive to active.
        ShowWindow( W->Wos ); 
        
        // Process all events generated by the prior call.
        ProcessPendingEvents();
        
        // Mark the window as visible.
        W->IsVisible = 1;
    }  
}

#endif // FOR_MACOS
