'From Squeak3.9 of 7 November 2006 [latest update: #7067] on 23 April 2007 at 2:11:33 pm'!"Change Set:		VmUpdates-1005-dtlDate:			23 April 2007Author:			David T. LewisUse new oop comparison methods throughout Interpreter wherever necessary to ensure unsigned operands. In some methods, the original comparison operators are used if referencing globals declared as usqInt, or if the methods are not inlined so that local declarations may be used.Update #stObject:at: and #stObject:at:put: to use the new comparison methods rather than Ian's original casts."!!Interpreter methodsFor: 'method lookup cache' stamp: 'dtl 4/22/2007 22:28'!flushMethodCacheFrom: memStart to: memEnd 	"Flush entries in the method cache only if the oop address is within the given memory range. 	This reduces overagressive cache clearing. Note the AtCache is fully flushed, 70% of the time 	cache entries live in newspace, new objects die young"	| probe |	probe := 0.	1 to: MethodCacheEntries do: [:i | 			(methodCache at: probe + MethodCacheSelector) = 0				ifFalse: [(((((self oop: (methodCache at: probe + MethodCacheSelector) isGreaterThanOrEqualTo: memStart)										and: [self oop: (methodCache at: probe + MethodCacheSelector) isLessThan: memEnd])									or: [(self oop: (methodCache at: probe + MethodCacheClass) isGreaterThanOrEqualTo: memStart)											and: [self oop: (methodCache at: probe + MethodCacheClass) isLessThan: memEnd]])								or: [(self oop: (methodCache at: probe + MethodCacheMethod) isGreaterThanOrEqualTo: memStart)										and: [self oop: (methodCache at: probe + MethodCacheMethod) isLessThan: memEnd]])							or: [(self oop: (methodCache at: probe + MethodCacheNative) isGreaterThanOrEqualTo: memStart)									and: [self oop: (methodCache at: probe + MethodCacheNative) isLessThan: memEnd]])						ifTrue: [methodCache at: probe + MethodCacheSelector put: 0]].			probe := probe + MethodCacheEntrySize].	1 to: AtCacheTotalSize do: [:i | atCache at: i put: 0]! !!Interpreter methodsFor: 'utilities' stamp: 'dtl 4/22/2007 23:45'!transfer: count from: src to: dst 	| in out lastIn |	self flag: #Dan.  "Need to check all senders before converting this for 64 bits"	self inline: true.	in := src - BytesPerWord.	lastIn := in + (count * BytesPerWord).	out := dst - BytesPerWord.	[self oop: in isLessThan: lastIn]		whileTrue: [self				longAt: (out := out + BytesPerWord)				put: (self longAt: (in := in + BytesPerWord))]! !!Interpreter methodsFor: 'utilities' stamp: 'dtl 4/22/2007 23:46'!transfer: count fromIndex: firstFrom ofObject: fromOop toIndex: firstTo ofObject: toOop	"Transfer the specified fullword fields, as from calling context to called context"		"Assume: beRootIfOld: will be called on toOop."	| fromIndex toIndex lastFrom |	self flag: #Dan.  "Need to check all senders before converting this for 64 bits"	self inline: true.	fromIndex := fromOop + (firstFrom * BytesPerWord).	toIndex := toOop + (firstTo * BytesPerWord).	lastFrom := fromIndex + (count * BytesPerWord).	[self oop: fromIndex isLessThan: lastFrom]		whileTrue: [fromIndex := fromIndex + BytesPerWord.			toIndex := toIndex + BytesPerWord.			self				longAt: toIndex				put: (self longAt: fromIndex)]! !!Interpreter methodsFor: 'debug support' stamp: 'dtl 4/22/2007 23:46'!verifyCleanHeaders	| oop |	oop := self firstObject.	[self oop: oop isLessThan: endOfMemory] whileTrue:		[(self isFreeObject: oop)			ifTrue: ["There should only be one free block at end of memory."					(self objectAfter: oop) = endOfMemory						ifFalse: [self error: 'Invalid obj with HeaderTypeBits = Free.']]			ifFalse: [((self longAt: oop) bitAnd: MarkBit) = 0						ifFalse: [self error: 'Invalid obj with MarkBit set.']].		oop := self objectAfter: oop]! !!Interpreter methodsFor: 'contexts' stamp: 'dtl 4/22/2007 23:26'!fetchContextRegisters: activeCntx 	"Note: internalFetchContextRegisters: should track changes  to this method."	| tmp |	self inline: true.	tmp := self fetchPointer: MethodIndex ofObject: activeCntx.	(self isIntegerObject: tmp)		ifTrue: ["if the MethodIndex field is an integer, activeCntx is a block context"			tmp := self fetchPointer: HomeIndex ofObject: activeCntx.			(self oop: tmp isLessThan: youngStart) ifTrue: [self beRootIfOld: tmp]]		ifFalse: ["otherwise, it is a method context and is its own home context "			tmp := activeCntx].	theHomeContext := tmp.	receiver := self fetchPointer: ReceiverIndex ofObject: tmp.	method := self fetchPointer: MethodIndex ofObject: tmp.	"the instruction pointer is a pointer variable equal to 	method oop + ip + BaseHeaderSize 	-1 for 0-based addressing of fetchByte 	-1 because it gets incremented BEFORE fetching currentByte "	tmp := self quickFetchInteger: InstructionPointerIndex ofObject: activeCntx.	instructionPointer := method + tmp + BaseHeaderSize - 2.	"the stack pointer is a pointer variable also..."	tmp := self quickFetchInteger: StackPointerIndex ofObject: activeCntx.	stackPointer := activeCntx + BaseHeaderSize + (TempFrameStart + tmp - 1 * BytesPerWord)! !!Interpreter methodsFor: 'contexts' stamp: 'dtl 4/22/2007 23:27'!internalFetchContextRegisters: activeCntx	"Inlined into return bytecodes. The only difference between this method and fetchContextRegisters: is that this method sets the local IP and SP."	| tmp |	self inline: true.	tmp := self fetchPointer: MethodIndex ofObject: activeCntx.	(self isIntegerObject: tmp) ifTrue: [		"if the MethodIndex field is an integer, activeCntx is a block context"		tmp := self fetchPointer: HomeIndex ofObject: activeCntx.		(self oop: tmp isLessThan: youngStart) ifTrue: [ self beRootIfOld: tmp ].	] ifFalse: [		"otherwise, it is a method context and is its own home context"		tmp := activeCntx.	].	localHomeContext := tmp.	receiver := self fetchPointer: ReceiverIndex ofObject: tmp.	method := self fetchPointer: MethodIndex ofObject: tmp.	"the instruction pointer is a pointer variable equal to		method oop + ip + BaseHeaderSize		  -1 for 0-based addressing of fetchByte		  -1 because it gets incremented BEFORE fetching currentByte"	tmp := self quickFetchInteger: InstructionPointerIndex ofObject: activeCntx.	localIP := self pointerForOop: method + tmp + BaseHeaderSize - 2.	"the stack pointer is a pointer variable also..."	tmp := self quickFetchInteger: StackPointerIndex ofObject: activeCntx.	localSP := self pointerForOop: activeCntx + BaseHeaderSize + ((TempFrameStart + tmp - 1) * BytesPerWord)! !!Interpreter methodsFor: 'contexts' stamp: 'dtl 4/22/2007 23:27'!internalNewActiveContext: aContext	"The only difference between this method and newActiveContext: is that this method uses internal context registers."	self inline: true.	self internalStoreContextRegisters: activeContext.	(self oop: aContext isLessThan: youngStart) ifTrue: [ self beRootIfOld: aContext ].	activeContext := aContext.	self internalFetchContextRegisters: aContext.! !!Interpreter methodsFor: 'contexts' stamp: 'dtl 4/22/2007 23:29'!newActiveContext: aContext	"Note: internalNewActiveContext: should track changes to this method."	self storeContextRegisters: activeContext.	(self oop: aContext isLessThan: youngStart) ifTrue: [ self beRootIfOld: aContext ].	activeContext := aContext.	self fetchContextRegisters: aContext.! !!Interpreter methodsFor: 'array and stream primitive support' stamp: 'dtl 4/22/2007 23:22'!commonVariable: rcvr at: index cacheIndex: atIx 	"This code assumes the reciever has been identified at location atIx in the atCache."	| stSize fmt fixedFields result |	stSize := atCache at: atIx+AtCacheSize.	((self oop: index isGreaterThanOrEqualTo: 1)		and: [self oop: index isLessThanOrEqualTo: stSize])	ifTrue:		[fmt := atCache at: atIx+AtCacheFmt.		fmt <= 4 ifTrue:			[fixedFields := atCache at: atIx+AtCacheFixedFields.			^ self fetchPointer: index + fixedFields - 1 ofObject: rcvr].		fmt < 8 ifTrue:  "Bitmap"			[result := self fetchLong32: index - 1 ofObject: rcvr.			result := self positive32BitIntegerFor: result.			^ result].		fmt >= 16  "Note fmt >= 16 is an artificial flag for strings"			ifTrue: "String"			[^ self characterForAscii: (self fetchByte: index - 1 ofObject: rcvr)]			ifFalse: "ByteArray"			[^ self integerObjectOf: (self fetchByte: index - 1 ofObject: rcvr)]].	self primitiveFail! !!Interpreter methodsFor: 'array and stream primitive support' stamp: 'dtl 4/22/2007 23:23'!commonVariable: rcvr at: index put: value cacheIndex: atIx	"This code assumes the reciever has been identified at location atIx in the atCache."	| stSize fmt fixedFields valToPut |	self inline: true.	stSize := atCache at: atIx+AtCacheSize.	((self oop: index isGreaterThanOrEqualTo: 1)		and: [self oop: index isLessThanOrEqualTo: stSize])	ifTrue:		[fmt := atCache at: atIx+AtCacheFmt.		fmt <= 4 ifTrue:			[fixedFields := atCache at: atIx+AtCacheFixedFields.			^ self storePointer: index + fixedFields - 1 ofObject: rcvr withValue: value].		fmt < 8 ifTrue:  "Bitmap"			[valToPut := self positive32BitValueOf: value.			successFlag ifTrue: [self storeLong32: index - 1 ofObject: rcvr withValue: valToPut].			^ nil].		fmt >= 16  "Note fmt >= 16 is an artificial flag for strings"			ifTrue: [valToPut := self asciiOfCharacter: value.					successFlag ifFalse: [^ nil]]			ifFalse: [valToPut := value].		(self isIntegerObject: valToPut) ifTrue:			[valToPut := self integerValueOf: valToPut.			((valToPut >= 0) and: [valToPut <= 255]) ifFalse: [^ self primitiveFail].			^ self storeByte: index - 1 ofObject: rcvr withValue: valToPut]].	self primitiveFail! !!Interpreter methodsFor: 'array and stream primitive support' stamp: 'dtl 4/22/2007 23:24'!commonVariableInternal: rcvr at: index cacheIndex: atIx 	"This code assumes the reciever has been identified at location atIx in the atCache."	| stSize fmt fixedFields result |	self inline: true.	stSize := atCache at: atIx+AtCacheSize.	((self oop: index isGreaterThanOrEqualTo: 1)		and: [self oop: index isLessThanOrEqualTo: stSize])	ifTrue:		[fmt := atCache at: atIx+AtCacheFmt.		fmt <= 4 ifTrue:			[fixedFields := atCache at: atIx+AtCacheFixedFields.			^ self fetchPointer: index + fixedFields - 1 ofObject: rcvr].		fmt < 8 ifTrue:  "Bitmap"			[result := self fetchLong32: index - 1 ofObject: rcvr.			self externalizeIPandSP.			result := self positive32BitIntegerFor: result.			self internalizeIPandSP.			^ result].		fmt >= 16  "Note fmt >= 16 is an artificial flag for strings"			ifTrue: "String"			[^ self characterForAscii: (self fetchByte: index - 1 ofObject: rcvr)]			ifFalse: "ByteArray"			[^ self integerObjectOf: (self fetchByte: index - 1 ofObject: rcvr)]].	self primitiveFail! !!Interpreter methodsFor: 'array and stream primitive support' stamp: 'dtl 4/22/2007 23:56'!stObject: array at: index	"Return what ST would return for <obj> at: index."	| hdr fmt totalLength fixedFields stSize |	self inline: false.	hdr := self baseHeader: array.	fmt := (hdr >> 8) bitAnd: 16rF.	totalLength := self lengthOf: array baseHeader: hdr format: fmt.	fixedFields := self fixedFieldsOf: array format: fmt length: totalLength.	(fmt = 3 and: [self isContextHeader: hdr])		ifTrue: [stSize := self fetchStackPointerOf: array]		ifFalse: [stSize := totalLength - fixedFields].	((self oop: index isGreaterThanOrEqualTo: 1)			and: [self oop: index isLessThanOrEqualTo: stSize])		ifTrue: [^ self subscript: array with: (index + fixedFields) format: fmt]		ifFalse: [successFlag := false.  ^ 0].! !!Interpreter methodsFor: 'array and stream primitive support' stamp: 'dtl 4/22/2007 23:56'!stObject: array at: index put: value	"Do what ST would return for <obj> at: index put: value."	| hdr fmt totalLength fixedFields stSize |	self inline: false.	hdr := self baseHeader: array.	fmt := (hdr >> 8) bitAnd: 16rF.	totalLength := self lengthOf: array baseHeader: hdr format: fmt.	fixedFields := self fixedFieldsOf: array format: fmt length: totalLength.	(fmt = 3 and: [self isContextHeader: hdr])		ifTrue: [stSize := self fetchStackPointerOf: array]		ifFalse: [stSize := totalLength - fixedFields].	((self oop: index isGreaterThanOrEqualTo: 1)			and: [self oop: index isLessThanOrEqualTo: stSize])		ifTrue: [self subscript: array with: (index + fixedFields) storing: value format: fmt]		ifFalse: [successFlag := false]! !!Interpreter methodsFor: 'image save/restore' stamp: 'dtl 4/22/2007 23:16'!byteSwapByteObjectsFrom: startOop to: stopAddr 	"Byte-swap the words of all bytes objects in a range of the 	image, including Strings, ByteArrays, and CompiledMethods. 	This returns these objects to their original byte ordering 	after blindly byte-swapping the entire image. For compiled 	methods, byte-swap only their bytecodes part."	| oop fmt wordAddr methodHeader |	oop := startOop.	[self oop: oop isLessThan: stopAddr]		whileTrue: [(self isFreeObject: oop)				ifFalse: [fmt := self formatOf: oop.					fmt >= 8						ifTrue: ["oop contains bytes"							wordAddr := oop + BaseHeaderSize.							fmt >= 12								ifTrue: ["compiled method; start after methodHeader and literals"									methodHeader := self longAt: oop + BaseHeaderSize.									wordAddr := wordAddr + BytesPerWord + ((methodHeader >> 10 bitAnd: 255) * BytesPerWord)].							self reverseBytesFrom: wordAddr to: oop + (self sizeBitsOf: oop)].					(fmt = 6 and: [BytesPerWord = 8])						ifTrue: ["Object contains 32-bit half-words packed into 64-bit machine words."							wordAddr := oop + BaseHeaderSize.							self reverseWordsFrom: wordAddr to: oop + (self sizeBitsOf: oop)]].			oop := self objectAfter: oop]! !!Interpreter methodsFor: 'image save/restore' stamp: 'dtl 4/22/2007 23:41'!reverseBytesFrom: startAddr to: stopAddr	"Byte-swap the given range of memory (not inclusive of stopAddr!!)."	| addr |	self flag: #Dan.	addr := startAddr.	[self oop: addr isLessThan: stopAddr] whileTrue:		[self longAt: addr put: (self byteSwapped: (self longAt: addr)).		addr := addr + BytesPerWord].! !!Interpreter methodsFor: 'image save/restore' stamp: 'dtl 4/22/2007 23:42'!reverseWordsFrom: startAddr to: stopAddr	"Word-swap the given range of memory, excluding stopAddr."	| addr |	addr := startAddr.	[self oop: addr isLessThan: stopAddr] whileTrue:		[self longAt: addr put: (self wordSwapped: (self longAt: addr)).		addr := addr + BytesPerWord].! !!Interpreter methodsFor: 'image save/restore' stamp: 'dtl 4/22/2007 23:42'!snapshotCleanUp	"Clean up right before saving an image, sweeping memory and:	* nilling out all fields of contexts above the stack pointer. 	* flushing external primitives 	* clearing the root bit of any object in the root table "	| oop header fmt sz |	oop := self firstObject.	[self oop: oop isLessThan: endOfMemory]		whileTrue: [(self isFreeObject: oop)				ifFalse: [header := self longAt: oop.					fmt := header >> 8 bitAnd: 15.					"Clean out context"					(fmt = 3 and: [self isContextHeader: header])						ifTrue: [sz := self sizeBitsOf: oop.							(self lastPointerOf: oop) + BytesPerWord								to: sz - BaseHeaderSize by: BytesPerWord								do: [:i | self longAt: oop + i put: nilObj]].					"Clean out external functions"					fmt >= 12						ifTrue: ["This is a compiled method"							(self primitiveIndexOf: oop) = PrimitiveExternalCallIndex								ifTrue: ["It's primitiveExternalCall"									self flushExternalPrimitiveOf: oop]]].			oop := self objectAfter: oop].	self clearRootsTable! !!Interpreter methodsFor: 'plugin primitive support' stamp: 'dtl 4/22/2007 23:27'!flushExternalPrimitives	"Flush the references to external functions from plugin 	primitives. This will force a reload of those primitives when 	accessed next. 	Note: We must flush the method cache here so that any 	failed primitives are looked up again."	| oop primIdx |	oop := self firstObject.	[self oop: oop isLessThan: endOfMemory]		whileTrue: [(self isFreeObject: oop)				ifFalse: [(self isCompiledMethod: oop)						ifTrue: ["This is a compiled method"							primIdx := self primitiveIndexOf: oop.							primIdx = PrimitiveExternalCallIndex								ifTrue: ["It's primitiveExternalCall"									self flushExternalPrimitiveOf: oop]]].			oop := self objectAfter: oop].	self flushMethodCache.	self flushObsoleteIndexedPrimitives.	self flushExternalPrimitiveTable! !!Interpreter methodsFor: 'object access primitives' stamp: 'dtl 4/22/2007 23:17'!changeClassOf: rcvr to: argClass	"Change the class of the receiver into the class specified by the argument given that the format of the receiver matches the format of the argument. Fail if receiver or argument are SmallIntegers, or the receiver is an instance of a compact class and the argument isn't, or when the argument's class is compact and the receiver isn't, or when the format of the receiver is different from the format of the argument's class, or when the arguments class is fixed and the receiver's size differs from the size that an instance of the argument's class should have."	| classHdr sizeHiBits byteSize argFormat rcvrFormat ccIndex |	"Check what the format of the class says"	classHdr := self formatOfClass: argClass. "Low 2 bits are 0"	"Compute the size of instances of the class (used for fixed field classes only)"	sizeHiBits := (classHdr bitAnd: 16r60000) >> 9.	classHdr := classHdr bitAnd: 16r1FFFF.	byteSize := (classHdr bitAnd: SizeMask) + sizeHiBits. "size in bytes -- low 2 bits are 0"	"Check the receiver's format against that of the class"	argFormat := (classHdr >> 8) bitAnd: 16rF.	rcvrFormat := self formatOf: rcvr.	argFormat = rcvrFormat ifFalse:[^self primitiveFail]. "no way"	"For fixed field classes, the sizes must match.	Note: byteSize-4 because base header is included in class size."	argFormat < 2 ifTrue:[(byteSize - BaseHeaderSize) = (self byteSizeOf: rcvr) ifFalse:[^self primitiveFail]].	(self headerType: rcvr) = HeaderTypeShort		ifTrue:[ "Compact classes. Check if the arg's class is compact and exchange ccIndex"			ccIndex := classHdr bitAnd: CompactClassMask.			ccIndex = 0 ifTrue:[^self primitiveFail]. "class is not compact"			self longAt: rcvr put:				(((self longAt: rcvr) bitAnd: CompactClassMask bitInvert32)					bitOr: ccIndex)]		ifFalse:["Exchange the class pointer, which could make rcvr a root for argClass"			self longAt: rcvr-BaseHeaderSize put: (argClass bitOr: (self headerType: rcvr)).			(self oop: rcvr isLessThan: youngStart)				ifTrue: [self possibleRootStoreInto: rcvr value: argClass]].	"Flush cache because rcvr's class has changed"	self flushMethodCache.! !!Interpreter methodsFor: 'object access primitives' stamp: 'dtl 4/22/2007 23:53'!primitiveStoreStackp	"Atomic store into context stackPointer. 	Also ensures that any newly accessible cells are initialized to nil "	| ctxt newStackp stackp |	ctxt := self stackValue: 1.	newStackp := self stackIntegerValue: 0.	self success: (self oop: newStackp isGreaterThanOrEqualTo: 0).	self success: (self oop: newStackp isLessThanOrEqualTo: (LargeContextSize - BaseHeaderSize // BytesPerWord - CtxtTempFrameStart)).	successFlag ifFalse: [^ self primitiveFail].	stackp := self fetchStackPointerOf: ctxt.	(self oop: newStackp isGreaterThan: stackp) ifTrue: ["Nil any newly accessible cells"			stackp + 1 to: newStackp do: [:i | self storePointer: i + CtxtTempFrameStart - 1 ofObject: ctxt withValue: nilObj]].	self storeStackPointerValue: newStackp inContext: ctxt.	self pop: 1! !!Interpreter methodsFor: 'return bytecodes' stamp: 'dtl 4/23/2007 09:01'!commonReturn	"Note: Assumed to be inlined into the dispatch loop."	| nilOop thisCntx contextOfCaller localCntx localVal unwindMarked |	self inline: true.	self sharedCodeNamed: 'commonReturn' inCase: 120.	nilOop := nilObj. "keep in a register"	thisCntx := activeContext.	localCntx := localReturnContext.	localVal := localReturnValue.	"make sure we can return to the given context"	((localCntx = nilOop) or:	 [(self fetchPointer: InstructionPointerIndex ofObject: localCntx) = nilOop]) ifTrue: [		"error: sender's instruction pointer or context is nil; cannot return"		^self internalCannotReturn: localVal].	"If this return is not to our immediate predecessor (i.e. from a method to its sender, or from a block to its caller), scan the stack for the first unwind marked context and inform this context and let it deal with it. This provides a chance for ensure unwinding to occur."	thisCntx := self fetchPointer: SenderIndex ofObject: activeContext.	"Just possibly a faster test would be to compare the homeContext and activeContext - they are of course different for blocks. Thus we might be able to optimise a touch by having a different returnTo for the blockreteurn (since we know that must return to caller) and then if active ~= home we must be doing a non-local return. I think. Maybe."	[thisCntx = localCntx] whileFalse: [		thisCntx = nilOop ifTrue:[			"error: sender's instruction pointer or context is nil; cannot return"			^self internalCannotReturn: localVal].		"Climb up stack towards localCntx. Break out to a send of #aboutToReturn:through: if an unwind marked context is found"		unwindMarked := self isUnwindMarked: thisCntx.		unwindMarked ifTrue:[			"context is marked; break out"			^self internalAboutToReturn: localVal through: thisCntx].		thisCntx := self fetchPointer: SenderIndex ofObject: thisCntx. ].	"If we get here there is no unwind to worry about. Simply terminate the stack up to the localCntx - often just the sender of the method"	thisCntx := activeContext.	[thisCntx = localCntx]		whileFalse:		["climb up stack to localCntx"		contextOfCaller := self fetchPointer: SenderIndex ofObject: thisCntx.		"zap exited contexts so any future attempted use will be caught"		self storePointerUnchecked: SenderIndex ofObject: thisCntx withValue: nilOop.		self storePointerUnchecked: InstructionPointerIndex ofObject: thisCntx withValue: nilOop.		reclaimableContextCount > 0 ifTrue:			["try to recycle this context"			reclaimableContextCount := reclaimableContextCount - 1.			self recycleContextIfPossible: thisCntx].		thisCntx := contextOfCaller].	activeContext := thisCntx.	(self oop: thisCntx isLessThan: youngStart) ifTrue: [ self beRootIfOld: thisCntx ].	self internalFetchContextRegisters: thisCntx.  "updates local IP and SP"	self fetchNextBytecode.	self internalPush: localVal.! !!Interpreter methodsFor: 'image segment in/out' stamp: 'dtl 4/22/2007 22:16'!copyObj: oop toSegment: segmentWordArray addr: lastSeg stopAt: stopAddr saveOopAt: oopPtr headerAt: hdrPtr	"Copy this object into the segment beginning at lastSeg.	Install a forwarding pointer, and save oop and header.	Fail if out of space.  Return the next segmentAddr if successful."	"Copy the object..."	| extraSize bodySize hdrAddr |	self flag: #Dan.  "None of the imageSegment stuff has been updated for 64 bits"	successFlag ifFalse: [^ lastSeg].	extraSize := self extraHeaderBytes: oop.	bodySize := self sizeBitsOf: oop.	(self oop: (lastSeg + extraSize + bodySize) isGreaterThanOrEqualTo: stopAddr)		ifTrue: [^ self primitiveFail].	self transfer: extraSize + bodySize // BytesPerWord  "wordCount"		from: oop - extraSize		to: lastSeg+BytesPerWord.	"Clear root and mark bits of all headers copied into the segment"	hdrAddr := lastSeg+BytesPerWord + extraSize.	self longAt: hdrAddr put: ((self longAt: hdrAddr) bitAnd: AllButRootBit - MarkBit).	self forward: oop to: (lastSeg+BytesPerWord + extraSize - segmentWordArray)		savingOopAt: oopPtr andHeaderAt: hdrPtr.	"Return new end of segment"	^ lastSeg + extraSize + bodySize! !!Interpreter methodsFor: 'image segment in/out' stamp: 'dtl 4/23/2007 00:06'!primitiveLoadImageSegment	"This primitive is called from Squeak as...		<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray.""This primitive will load a binary image segment created by primitiveStoreImageSegment.  It expects the outPointer array to be of the proper size, and the wordArray to be well formed.  It will return as its value the original array of roots, and the erstwhile segmentWordArray will have been truncated to a size of zero.  If this primitive should fail, the segmentWordArray will, sadly, have been reduced to an unrecognizable and unusable jumble.  But what more could you have done with it anyway?"	| outPointerArray segmentWordArray endSeg segOop fieldPtr fieldOop doingClass lastPtr extraSize mapOop lastOut outPtr hdrTypeBits header data |	self var: #endSeg type: 'usqInt'.	self var: #segOop type: 'usqInt'.	self var: #fieldPtr type: 'usqInt'.	self var: #lastOut type: 'usqInt'.	self var: #outPtr type: 'usqInt'.	self var: #lastPtr type: 'usqInt'.	DoAssertionChecks ifTrue: [self verifyCleanHeaders].	outPointerArray := self stackTop.	lastOut := outPointerArray + (self lastPointerOf: outPointerArray).	segmentWordArray := self stackValue: 1.	endSeg := segmentWordArray + (self sizeBitsOf: segmentWordArray) - BaseHeaderSize.	"Essential type checks"	((self formatOf: outPointerArray) = 2				"Must be indexable pointers"		and: [(self formatOf: segmentWordArray) = 6])	"Must be indexable words"		ifFalse: [^ self primitiveFail].	"Version check.  Byte order of the WordArray now"	data := self longAt: segmentWordArray + BaseHeaderSize.	(self readableFormat: (data bitAnd: 16rFFFF "low 2 bytes")) ifFalse: [		"Not readable -- try again with reversed bytes..."		self reverseBytesFrom: segmentWordArray + BaseHeaderSize to: endSeg + BytesPerWord.		data := self longAt: segmentWordArray + BaseHeaderSize.		(self readableFormat: (data bitAnd: 16rFFFF "low 2 bytes")) ifFalse: [			"Still NG -- put things back and fail"			self reverseBytesFrom: segmentWordArray + BaseHeaderSize to: endSeg + BytesPerWord.			DoAssertionChecks ifTrue: [self verifyCleanHeaders].			^ self primitiveFail]].	"Reverse the Byte type objects if the data from opposite endian machine"	"Test top byte.  $d on the Mac or $s on the PC.  Rest of word is equal"	data = self imageSegmentVersion ifFalse: [		"Reverse the byte-type objects once"		segOop := self oopFromChunk: segmentWordArray + BaseHeaderSize + BytesPerWord.			 "Oop of first embedded object"		self byteSwapByteObjectsFrom: segOop to: endSeg + BytesPerWord].	"Proceed through the segment, remapping pointers..."	segOop := self oopFromChunk: segmentWordArray + BaseHeaderSize + BytesPerWord.	[segOop <= endSeg] whileTrue:		[(self headerType: segOop) <= 1			ifTrue: ["This object has a class field (type = 0 or 1) -- start with that."					fieldPtr := segOop - BytesPerWord.  doingClass := true]			ifFalse: ["No class field -- start with first data field"					fieldPtr := segOop + BaseHeaderSize.  doingClass := false].		lastPtr := segOop + (self lastPointerOf: segOop).	"last field"		lastPtr > endSeg ifTrue: [			DoAssertionChecks ifTrue: [self verifyCleanHeaders].			^ self primitiveFail "out of bounds"].		"Go through all oops, remapping them..."		[fieldPtr > lastPtr] whileFalse:			["Examine each pointer field"			fieldOop := self longAt: fieldPtr.			doingClass ifTrue:				[hdrTypeBits := self headerType: fieldPtr.				fieldOop := fieldOop - hdrTypeBits].			(self isIntegerObject: fieldOop)				ifTrue:					["Integer -- nothing to do"					fieldPtr := fieldPtr + BytesPerWord]				ifFalse:					[(fieldOop bitAnd: 3) = 0 ifFalse: [^ self primitiveFail "bad oop"].					(fieldOop bitAnd: 16r80000000) = 0						ifTrue: ["Internal pointer -- add segment offset"								mapOop := fieldOop + segmentWordArray]						ifFalse: ["External pointer -- look it up in outPointers"								outPtr := outPointerArray + (fieldOop bitAnd: 16r7FFFFFFF).								outPtr > lastOut ifTrue: [^ self primitiveFail "out of bounds"].								mapOop := self longAt: outPtr].					doingClass						ifTrue: [self longAt: fieldPtr put: mapOop + hdrTypeBits.								fieldPtr := fieldPtr + 8.								doingClass := false]						ifFalse: [self longAt: fieldPtr put: mapOop.								fieldPtr := fieldPtr + BytesPerWord].					segOop < youngStart						ifTrue: [self possibleRootStoreInto: segOop value: mapOop].					]].		segOop := self objectAfter: segOop].	"Again, proceed through the segment checking consistency..."	segOop := self oopFromChunk: segmentWordArray + BaseHeaderSize + BytesPerWord.	[segOop <= endSeg] whileTrue:		[(self oopHasAcceptableClass: segOop) ifFalse: [^ self primitiveFail "inconsistency"].		fieldPtr := segOop + BaseHeaderSize.		"first field"		lastPtr := segOop + (self lastPointerOf: segOop).	"last field"		"Go through all oops, remapping them..."		[fieldPtr > lastPtr] whileFalse:			["Examine each pointer field"			fieldOop := self longAt: fieldPtr.			(self oopHasAcceptableClass: fieldOop) ifFalse: [^ self primitiveFail "inconsistency"].			fieldPtr := fieldPtr + BytesPerWord].		segOop := self objectAfter: segOop].	"Truncate the segment word array to size = BytesPerWord (vers stamp only)"	extraSize := self extraHeaderBytes: segmentWordArray.	hdrTypeBits := self headerType: segmentWordArray.	extraSize = 8		ifTrue: [self longAt: segmentWordArray-extraSize put: BaseHeaderSize + BytesPerWord + hdrTypeBits]		ifFalse: [header := self longAt: segmentWordArray.				self longAt: segmentWordArray					put: header - (header bitAnd: SizeMask) + BaseHeaderSize + BytesPerWord].		"and return the roots array which was first in the segment"	DoAssertionChecks ifTrue: [self verifyCleanHeaders].	self pop: 3 thenPush: (self oopFromChunk: segmentWordArray + BaseHeaderSize + BytesPerWord).! !!Interpreter methodsFor: 'image segment in/out' stamp: 'dtl 4/22/2007 23:10'!primitiveStoreImageSegment	"This primitive is called from Squeak as...		<imageSegment> storeSegmentFor: arrayOfRoots into: aWordArray outPointers: anArray.""This primitive will store a binary image segment (in the same format as the Squeak image file) of the receiver and every object in its proper tree of subParts (ie, that is not refered to from anywhere else outside the tree).  All pointers from within the tree to objects outside the tree will be copied into the array of outpointers.  In their place in the image segment will be an oop equal to the offset in the outPointer array (the first would be 4). but with the high bit set.""The primitive expects the array and wordArray to be more than adequately long.  In this case it returns normally, and truncates the two arrays to exactly the right size.  To simplify truncation, both incoming arrays are required to be 256 bytes or more long (ie with 3-word headers).  If either array is too small, the primitive will fail, but in no other case.During operation of the primitive, it is necessary to convert from both internal and external oops to their mapped values.  To make this fast, the headers of the original objects in question are replaced by the mapped values (and this is noted by adding the forbidden XX header type).  Tables are kept of both kinds of oops, as well as of the original headers for restoration.To be specific, there are two similar two-part tables, the outpointer array, and one in the upper fifth of the segmentWordArray.  Each grows oops from the bottom up, and preserved headers from halfway up.In case of either success or failure, the headers must be restored.  In the event of primitive failure, the table of outpointers must also be nilled out (since the garbage in the high half will not have been discarded."	| outPointerArray segmentWordArray savedYoungStart lastOut lastIn firstIn lastSeg endSeg segOop fieldPtr fieldOop mapOop doingClass lastPtr extraSize hdrTypeBits arrayOfRoots hdrBaseIn hdrBaseOut header firstOut versionOffset |	self var: #firstIn type: 'usqInt'.	self var: #lastIn type: 'usqInt'.	self var: #firstOut type: 'usqInt'.	self var: #lastOut type: 'usqInt'.	self var: #hdrBaseIn type: 'usqInt'.	self var: #hdrBaseOut type: 'usqInt'.	self var: #lastSeg type: 'usqInt'.	self var: #endSeg type: 'usqInt'.	self var: #fieldPtr type: 'usqInt'.	self var: #lastPtr type: 'usqInt'.	self var: #segOop type: 'usqInt'.	self var: #savedYoungStart type: 'usqInt'.	outPointerArray := self stackTop.	segmentWordArray := self stackValue: 1.	arrayOfRoots := self stackValue: 2.	"Essential type checks"	((self formatOf: arrayOfRoots) = 2				"Must be indexable pointers"		and: [(self formatOf: outPointerArray) = 2				"Must be indexable pointers"		and: [(self formatOf: segmentWordArray) = 6]])	"Must be indexable words"		ifFalse: [^ self primitiveFail].	((self headerType: outPointerArray) = HeaderTypeSizeAndClass	"Must be 3-word header"		and: [(self headerType: segmentWordArray) = HeaderTypeSizeAndClass])	"Must be 3-word header"		ifFalse: [^ self primitiveFail].	DoAssertionChecks ifTrue: [self verifyCleanHeaders].	"Use the top half of outPointers for saved headers."	firstOut := outPointerArray + BaseHeaderSize.	lastOut := firstOut - BytesPerWord.	hdrBaseOut := outPointerArray + ((self lastPointerOf: outPointerArray) // (BytesPerWord*2) * BytesPerWord). "top half"	lastSeg := segmentWordArray.	endSeg := segmentWordArray + (self sizeBitsOf: segmentWordArray) - BytesPerWord.	"Write a version number for byte order and version check"	versionOffset := BytesPerWord.	lastSeg := lastSeg + versionOffset.	lastSeg > endSeg ifTrue: [^ self primitiveFail].	self longAt: lastSeg put: self imageSegmentVersion.	"Allocate top 1/8 of segment for table of internal oops and saved headers"	firstIn := endSeg - ((self sizeBitsOf: segmentWordArray) // (BytesPerWord*8) * BytesPerWord).  "Take 1/8 of seg"	lastIn := firstIn - BytesPerWord.	hdrBaseIn := firstIn + ((self sizeBitsOf: segmentWordArray) // (BytesPerWord*16) * BytesPerWord). "top half of that"	"First mark the rootArray and all root objects."	self longAt: arrayOfRoots put: ((self longAt: arrayOfRoots) bitOr: MarkBit).	lastPtr := arrayOfRoots + (self lastPointerOf: arrayOfRoots).	fieldPtr := arrayOfRoots + BaseHeaderSize.	[fieldPtr <= lastPtr] whileTrue:		[fieldOop := self longAt: fieldPtr.		(self isIntegerObject: fieldOop) ifFalse:			[self longAt: fieldOop put: ((self longAt: fieldOop) bitOr: MarkBit)].		fieldPtr := fieldPtr + BytesPerWord].	"Then do a mark pass over all objects.  This will stop at our marked roots,	thus leaving our segment unmarked in their shadow."	savedYoungStart := youngStart.	youngStart := self startOfMemory.  "process all of memory"		"clear the recycled context lists"		freeContexts := NilContext.		freeLargeContexts := NilContext.	self markAndTraceInterpreterOops.	"and special objects array"	youngStart := savedYoungStart.		"Finally unmark the rootArray and all root objects."	self longAt: arrayOfRoots put: ((self longAt: arrayOfRoots) bitAnd: AllButMarkBit).	fieldPtr := arrayOfRoots + BaseHeaderSize.	[fieldPtr <= lastPtr] whileTrue:		[fieldOop := self longAt: fieldPtr.		(self isIntegerObject: fieldOop) ifFalse:			[self longAt: fieldOop put: ((self longAt: fieldOop) bitAnd: AllButMarkBit)].		fieldPtr := fieldPtr + BytesPerWord].	"All external objects, and only they, are now marked.	Copy the array of roots into the segment, and forward its oop."	lastIn := lastIn + BytesPerWord.	lastIn >= hdrBaseIn ifTrue: [successFlag := false].	lastSeg := self copyObj: arrayOfRoots toSegment: segmentWordArray addr: lastSeg stopAt: firstIn saveOopAt: lastIn headerAt: hdrBaseIn + (lastIn - firstIn).	successFlag ifFalse:		[lastIn := lastIn - BytesPerWord.		self restoreHeadersFrom: firstIn to: lastIn from: hdrBaseIn and: firstOut to: lastOut from: hdrBaseOut.		^ self primitiveFailAfterCleanup: outPointerArray].	"Now run through the segment fixing up all the pointers.	Note that more objects will be added to the segment as we make our way along."	segOop := self oopFromChunk: segmentWordArray + versionOffset + BaseHeaderSize.	[segOop <= lastSeg] whileTrue:		[(self headerType: segOop) <= 1			ifTrue: ["This object has a class field (type=0 or 1) -- start with that."					fieldPtr := segOop - BytesPerWord.  doingClass := true]			ifFalse: ["No class field -- start with first data field"					fieldPtr := segOop + BaseHeaderSize.  doingClass := false].		lastPtr := segOop + (self lastPointerOf: segOop).	"last field"		"Go through all oops, remapping them..."		[fieldPtr > lastPtr] whileFalse:			["Examine each pointer field"			fieldOop := self longAt: fieldPtr.			doingClass ifTrue:				[hdrTypeBits := fieldOop bitAnd: TypeMask.				fieldOop := fieldOop - hdrTypeBits].			(self isIntegerObject: fieldOop)				ifTrue: ["Just an integer -- nothing to do"						fieldPtr := fieldPtr + BytesPerWord]				ifFalse:				[header := self longAt: fieldOop.				(header bitAnd: TypeMask) = HeaderTypeFree					ifTrue: ["Has already been forwarded -- this is the link"							mapOop := header bitAnd: AllButTypeMask]					ifFalse:					[((self longAt: fieldOop) bitAnd: MarkBit) = 0						ifTrue:							["Points to an unmarked obj -- an internal pointer.							Copy the object into the segment, and forward its oop."							lastIn := lastIn + BytesPerWord.							lastIn >= hdrBaseIn ifTrue: [successFlag := false].							lastSeg := self copyObj: fieldOop toSegment: segmentWordArray addr: lastSeg stopAt: firstIn saveOopAt: lastIn headerAt: hdrBaseIn + (lastIn - firstIn).							successFlag ifFalse:								["Out of space in segment"								lastIn := lastIn - BytesPerWord.								self restoreHeadersFrom: firstIn to: lastIn from: hdrBaseIn and: firstOut to: lastOut from: hdrBaseOut.								^ self primitiveFailAfterCleanup: outPointerArray].							mapOop := (self longAt: fieldOop) bitAnd: AllButTypeMask]						ifFalse:							["Points to a marked obj -- an external pointer.							Map it as a tagged index in outPointers, and forward its oop."							lastOut := lastOut + BytesPerWord.							lastOut >= hdrBaseOut ifTrue:								["Out of space in outPointerArray"								lastOut := lastOut - BytesPerWord.								self restoreHeadersFrom: firstIn to: lastIn from: hdrBaseIn and: firstOut to: lastOut from: hdrBaseOut.								^ self primitiveFailAfterCleanup: outPointerArray]..							mapOop := lastOut - outPointerArray bitOr: 16r80000000.							self forward: fieldOop to: mapOop								savingOopAt: lastOut andHeaderAt: hdrBaseOut + (lastOut - firstOut)]].					"Replace the oop by its mapped value"					doingClass						ifTrue: [self longAt: fieldPtr put: mapOop + hdrTypeBits.								fieldPtr := fieldPtr + (BytesPerWord*2).								doingClass := false]						ifFalse: [self longAt: fieldPtr put: mapOop.								fieldPtr := fieldPtr + BytesPerWord].]].		segOop := self objectAfter: segOop].	self restoreHeadersFrom: firstIn to: lastIn from: hdrBaseIn and: firstOut to: lastOut from: hdrBaseOut.	"Truncate the outPointerArray..."	((outPointerArray + (self lastPointerOf: outPointerArray) - lastOut) < 12		or: [(endSeg - lastSeg) < 12]) ifTrue:			["Not enough room to insert simple 3-word headers"			^ self primitiveFailAfterCleanup: outPointerArray].	extraSize := self extraHeaderBytes: segmentWordArray.	hdrTypeBits := self headerType: segmentWordArray.	"Copy the 3-word wordArray header to establish a free chunk."	self transfer: 3		from: segmentWordArray - extraSize		to: lastOut+BytesPerWord.	"Adjust the size of the original as well as the free chunk."	self longAt: lastOut+BytesPerWord		put: outPointerArray + (self lastPointerOf: outPointerArray) - lastOut - extraSize + hdrTypeBits.	self longAt: outPointerArray-extraSize		put: lastOut - firstOut + (BytesPerWord*2) + hdrTypeBits.	"Note that pointers have been stored into roots table"	self beRootIfOld: outPointerArray.	"Truncate the image segment..."	"Copy the 3-word wordArray header to establish a free chunk."	self transfer: 3		from: segmentWordArray - extraSize		to: lastSeg+BytesPerWord.	"Adjust the size of the original as well as the free chunk."	self longAt: segmentWordArray-extraSize		put: lastSeg - segmentWordArray + BaseHeaderSize + hdrTypeBits.	self longAt: lastSeg+BytesPerWord		put: endSeg - lastSeg - extraSize + hdrTypeBits.	DoAssertionChecks ifTrue: [self verifyCleanHeaders].	self pop: 3.  "...leaving the reciever on the stack as return value"! !!Interpreter methodsFor: 'image segment in/out' stamp: 'dtl 4/22/2007 23:40'!restoreHeadersFrom: firstIn to: lastIn from: hdrBaseIn and: firstOut to: lastOut from: hdrBaseOut	"Restore headers smashed by forwarding links"	| tablePtr oop header |	tablePtr := firstIn.	[self oop: tablePtr isLessThanOrEqualTo: lastIn] whileTrue:		[oop := self longAt: tablePtr.		header := self longAt: hdrBaseIn + (tablePtr-firstIn).		self longAt: oop put: header.		tablePtr := tablePtr + BytesPerWord].	tablePtr := firstOut.	[self oop: tablePtr isLessThanOrEqualTo: lastOut] whileTrue:		[oop := self longAt: tablePtr.		header := self longAt: hdrBaseOut + (tablePtr-firstOut).		self longAt: oop put: header.		tablePtr := tablePtr + BytesPerWord].		"Clear all mark bits"	oop := self firstObject.	[self oop: oop isLessThan: endOfMemory] whileTrue:		[(self isFreeObject: oop) ifFalse:			[self longAt: oop put: ((self longAt: oop) bitAnd: AllButMarkBit)].		oop := self objectAfter: oop].! !!Interpreter methodsFor: 'debug printing' stamp: 'dtl 4/22/2007 23:38'!printAllStacks	"Print all the stacks of all running processes, including those that are currently suspended."	| oop proc ctx |	proc := self fetchPointer: ActiveProcessIndex ofObject: self schedulerPointer.	self printNameOfClass: (self fetchClassOf: proc) count: 5.	self cr.	self printCallStackOf: activeContext. "first the active context"	oop := self firstObject.	[self oop: oop isLessThan: endOfMemory] whileTrue:[		(self fetchClassOf: oop) == self classSemaphore ifTrue:[			self cr.			proc := self fetchPointer: FirstLinkIndex ofObject: oop.			[proc == self nilObject] whileFalse:[				self printNameOfClass: (self fetchClassOf: proc) count: 5.				self cr.				ctx := self fetchPointer: SuspendedContextIndex ofObject: proc.				ctx == self nilObject ifFalse:[self printCallStackOf: ctx].				proc := self fetchPointer: NextLinkIndex ofObject: proc].		].		oop := self objectAfter: oop.	].! !!Interpreter methodsFor: 'initialization' stamp: 'dtl 4/22/2007 23:29'!loadInitialContext	| sched proc |	sched := self fetchPointer: ValueIndex ofObject: (self splObj: SchedulerAssociation).	proc := self fetchPointer: ActiveProcessIndex ofObject: sched.	activeContext := self fetchPointer: SuspendedContextIndex ofObject: proc.	(self oop: activeContext isLessThan: youngStart) ifTrue: [ self beRootIfOld: activeContext ].	self fetchContextRegisters: activeContext.	reclaimableContextCount := 0.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'dtl 4/22/2007 23:43'!storeAndPopReceiverVariableBytecode	"Note: This code uses 	storePointerUnchecked:ofObject:withValue: and does the 	store check explicitely in order to help the translator 	produce better code."	| rcvr top |	self fetchNextBytecode.	"this bytecode will be expanded so that refs to 	currentBytecode below will be constant"	rcvr := receiver.	top := self internalStackTop.	(self oop: rcvr isLessThan: youngStart)		ifTrue: [self possibleRootStoreInto: rcvr value: top].	self storePointerUnchecked: (currentBytecode bitAnd: 7) ofObject: rcvr withValue: top.	self internalPop: 1! !!Interpreter methodsFor: 'object memory support' stamp: 'dtl 4/22/2007 23:31'!postGCAction	"Mark the active and home contexts as roots if old. This 	allows the interpreter to use storePointerUnchecked to 	store into them."	compilerInitialized		ifTrue: [self compilerPostGC]		ifFalse: [(self oop: activeContext isLessThan: youngStart)				ifTrue: [self beRootIfOld: activeContext].			(self oop: theHomeContext isLessThan: youngStart)				ifTrue: [self beRootIfOld: theHomeContext]].	(self sizeOfFree: freeBlock) > shrinkThreshold		ifTrue: ["Attempt to shrink memory after successfully 			reclaiming lots of memory"			self shrinkObjectMemory: (self sizeOfFree: freeBlock) - growHeadroom].		self signalSemaphoreWithIndex: gcSemaphoreIndex.! !!Interpreter methodsFor: 'memory space primitives' stamp: 'dtl 4/22/2007 22:51'!primitiveIsYoung	"Primitive. Answer whether the argument to the primitive resides in young space."	| oop |	self export: true.	oop := self stackObjectValue: 0.	successFlag ifTrue:[		self pop: argumentCount + 1.		self pushBool: (self oop: oop isGreaterThanOrEqualTo: youngStart).	].! !!Interpreter methodsFor: 'sound primitives' stamp: 'dtl 4/22/2007 23:33'!primitiveConstantFill	"Fill the receiver, which must be an indexable bytes or words 	objects, with the given integer value."	| fillValue rcvr rcvrIsBytes end i |	self var: #end type: 'usqInt'.	self var: #i type: 'usqInt'.	fillValue := self positive32BitValueOf: self stackTop.	rcvr := self stackValue: 1.	self success: (self isWordsOrBytes: rcvr).	rcvrIsBytes := self isBytes: rcvr.	rcvrIsBytes ifTrue: [self success: (fillValue >= 0 and: [fillValue <= 255])].	successFlag		ifTrue: [end := rcvr + (self sizeBitsOf: rcvr).			i := rcvr + BaseHeaderSize.			rcvrIsBytes				ifTrue: [[i < end]						whileTrue: [self byteAt: i put: fillValue.							i := i + 1]]				ifFalse: [[i < end]						whileTrue: [self long32At: i put: fillValue.							i := i + 4]].			self pop: 1]! !!Interpreter methodsFor: 'quick primitives' stamp: 'dtl 4/22/2007 23:35'!primitiveInstVarsPutFromStack	"Note:  this primitive has been decommissioned.  It is only here for short-term compatibility with an internal 2.3beta-d image that used this.  It did not save much time and it complicated several things.  Plus Jitter will do it right anyway."	| rcvr offsetBits |	rcvr := self stackValue: argumentCount.	"Mark dirty so stores below can be unchecked"	(self oop: rcvr isLessThan: youngStart) ifTrue: [ self beRootIfOld: rcvr ].	0 to: argumentCount-1 do:		[:i | (i bitAnd: 3) = 0 ifTrue:			[offsetBits := self positive32BitValueOf: (self literal: i//4 ofMethod: newMethod)].		self storePointerUnchecked: (offsetBits bitAnd: 16rFF) ofObject: rcvr						withValue: (self stackValue: i).		offsetBits := offsetBits >> 8].	self pop: argumentCount! !