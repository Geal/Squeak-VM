'From Squeak3.9 of 7 November 2006 [latest update: #7067] on 23 April 2007 at 2:11:30 pm'!"Change Set:		VmUpdates-1004-dtlDate:			23 April 2007Author:			David T. LewisUse new oop comparison methods throughout ObjectMemory wherever necessary to ensure unsigned operands. In some methods, the original comparison operators are used if referencing globals declared as usqInt, or if the methods are not inlined so that local declarations may be used.Updated #sufficientSpaceAfterGC:, #sufficientSpaceToAllocate:  and #allocateChunk to use the new methods rather than Ian's original casts."!!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'dtl 4/22/2007 20:07'!markAndTrace: oop	"Mark all objects reachable from the given one.	Trace from the given object even if it is old.	Do not trace if it is already marked.	Mark it only if it is a young object."	"Tracer state variables:		child		object being examined		field		next field of child to examine		parentField	field where child was stored in its referencing object"	| header lastFieldOffset action statMarkCountLocal |	header := self longAt: oop.	(header bitAnd: MarkBit) = 0 ifFalse: [^ 0  "already marked"].	"record tracing status in object's header"	header := (header bitAnd: AllButTypeMask) bitOr: HeaderTypeGC.	(self oop: oop isGreaterThanOrEqualTo: youngStart)		ifTrue: [ header := header bitOr: MarkBit ].  "mark only if young"	self longAt: oop put: header.	"initialize the tracer state machine"	parentField := GCTopMarker.	child := oop.	(self isWeakNonInt: oop) ifTrue: [		"Set lastFieldOffset before the weak fields in the receiver"		lastFieldOffset := (self nonWeakFieldsOf: oop) << ShiftForWord.		"And remember as weak root"		weakRootCount := weakRootCount + 1.		weakRoots at: weakRootCount put: oop.	] ifFalse: [		"Do it the usual way"		lastFieldOffset := self lastPointerOf: oop.	].	field := oop + lastFieldOffset.	action := StartField.	youngStartLocal := youngStart.	statMarkCountLocal := statMarkCount.	"run the tracer state machine until all objects reachable from oop are marked"	[action = Done] whileFalse: [		statMarkCountLocal := statMarkCountLocal + 1.		action = StartField ifTrue: [ action := self startField ].		action = StartObj ifTrue: [ action := self startObj ].		action = Upward ifTrue: [ action := self upward ].	].	statMarkCount := statMarkCountLocal.! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'dtl 4/22/2007 21:26'!startObj	"Start tracing the object 'child' and answer the next action. 	The object may be anywhere in the middle of being swept 	itself. See comment in markAndTrace for explanation of 	tracer state variables."	| oop header lastFieldOffset |	self inline: true.	oop := child.	(self oop: oop isLessThan: youngStartLocal)		ifTrue: ["old object; skip it"			field := oop.			^ Upward].	header := self longAt: oop.	(header bitAnd: MarkBit) = 0		ifTrue: ["unmarked; mark and trace"			"Do not trace the object's indexed fields if it's a weak class "			(self isWeakNonInt: oop)				ifTrue: ["Set lastFieldOffset before the weak fields in the receiver "					lastFieldOffset := (self nonWeakFieldsOf: oop) << ShiftForWord]				ifFalse: ["Do it the usual way"					lastFieldOffset := self lastPointerOf: oop].			header := header bitAnd: AllButTypeMask.			header := (header bitOr: MarkBit) bitOr: HeaderTypeGC.			self longAt: oop put: header.			field := oop + lastFieldOffset.			^ StartField "trace its fields and class"]		ifFalse: ["already marked; skip it"			field := oop.			^ Upward]! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'dtl 4/22/2007 21:29'!sweepPhase	"Sweep memory from youngStart through the end of memory. Free all 	inaccessible objects and coalesce adjacent free chunks. Clear the mark 	bits of accessible objects. Compute the starting point for the first pass of 	incremental compaction (compStart). Return the number of surviving 	objects. "	"Details: Each time a non-free object is encountered, decrement the 	number of available forward table entries. If all entries are spoken for 	(i.e., entriesAvailable reaches zero), set compStart to the last free 	chunk before that object or, if there is no free chunk before the given 	object, the first free chunk after it. Thus, at the end of the sweep 	phase, compStart through compEnd spans the highest collection of 	non-free objects that can be accomodated by the forwarding table. This 	information is used by the first pass of incremental compaction to 	ensure that space is initially freed at the end of memory. Note that 	there should always be at least one free chunk--the one at the end of 	the heap."	| entriesAvailable survivors freeChunk firstFree oop oopHeader oopHeaderType hdrBytes oopSize freeChunkSize endOfMemoryLocal |	self inline: false.	self var: #oop type: 'usqInt'.	self var: #endOfMemoryLocal type: 'usqInt'.	entriesAvailable := self fwdTableInit: BytesPerWord*2.	survivors := 0.	freeChunk := nil.	firstFree := nil.	"will be updated later"	endOfMemoryLocal := endOfMemory.	oop := self oopFromChunk: youngStart.	[oop < endOfMemoryLocal]		whileTrue: ["get oop's header, header type, size, and header size"			statSweepCount := statSweepCount + 1.			oopHeader := self baseHeader: oop.			oopHeaderType := oopHeader bitAnd: TypeMask.			hdrBytes := headerTypeBytes at: oopHeaderType.			(oopHeaderType bitAnd: 1) = 1				ifTrue: [oopSize := oopHeader bitAnd: SizeMask]				ifFalse: [oopHeaderType = HeaderTypeSizeAndClass						ifTrue: [oopSize := (self sizeHeader: oop) bitAnd: LongSizeMask]						ifFalse: ["free chunk" oopSize := oopHeader bitAnd: LongSizeMask]].			(oopHeader bitAnd: MarkBit) = 0				ifTrue: ["object is not marked; free it"					"<-- Finalization support: We need to mark each oop chunk as free -->"					self longAt: oop - hdrBytes put: HeaderTypeFree.					freeChunk ~= nil						ifTrue: ["enlarge current free chunk to include this oop"							freeChunkSize := freeChunkSize + oopSize + hdrBytes]						ifFalse: ["start a new free chunk"							freeChunk := oop - hdrBytes.							"chunk may start 4 or 8 bytes before oop"							freeChunkSize := oopSize + (oop - freeChunk).							"adjust size for possible extra header bytes"							firstFree = nil ifTrue: [firstFree := freeChunk]]]				ifFalse: ["object is marked; clear its mark bit and possibly adjust 					the compaction start"					self longAt: oop put: (oopHeader bitAnd: AllButMarkBit).					"<-- Finalization support: Check if we're running about a weak class -->"					(self isWeakNonInt: oop) ifTrue: [self finalizeReference: oop].					entriesAvailable > 0						ifTrue: [entriesAvailable := entriesAvailable - 1]						ifFalse: ["start compaction at the last free chunk before this object"							firstFree := freeChunk].					freeChunk ~= nil						ifTrue: ["record the size of the last free chunk"							self longAt: freeChunk put: ((freeChunkSize bitAnd: LongSizeMask) bitOr: HeaderTypeFree).							freeChunk := nil].					survivors := survivors + 1].			oop := self oopFromChunk: oop + oopSize].	freeChunk ~= nil		ifTrue: ["record size of final free chunk"			self longAt: freeChunk put: ((freeChunkSize bitAnd: LongSizeMask) bitOr: HeaderTypeFree)].	oop = endOfMemory		ifFalse: [self error: 'sweep failed to find exact end of memory'].	firstFree = nil		ifTrue: [self error: 'expected to find at least one free object']		ifFalse: [compStart := firstFree].	^ survivors! !!ObjectMemory methodsFor: 'finalization' stamp: 'dtl 4/22/2007 21:18'!finalizeReference: oop 	"During sweep phase we have encountered a weak reference. 	Check if  its object has gone away (or is about to) and if so, signal a 	semaphore. "	"Do *not* inline this in sweepPhase - it is quite an unlikely 	case to run into a weak reference"	| weakOop oopGone chunk firstField lastField |	self inline: false.	self var: #oop type: 'usqInt'.	self var: #weakOop type: 'usqInt'.	firstField := BaseHeaderSize + ((self nonWeakFieldsOf: oop) << ShiftForWord).	lastField := self lastPointerOf: oop.	firstField to: lastField by: BytesPerWord do: [:i | 			weakOop := self longAt: oop + i.			"ar 1/18/2005: Added oop < youngStart test to make sure we're not testing			objects in non-GCable region. This could lead to a forward reference in			old space with the oop pointed to not being marked and thus treated as free."			(weakOop == nilObj or: [(self isIntegerObject: weakOop) or:[weakOop < youngStart]])				ifFalse: ["Check if the object is being collected. 					If the weak reference points  					* backward: check if the weakOops chunk is free					* forward: check if the weakOoop has been marked by GC"					weakOop < oop						ifTrue: [chunk := self chunkFromOop: weakOop.							oopGone := ((self longAt: chunk) bitAnd: TypeMask) = HeaderTypeFree]						ifFalse: [oopGone := ((self baseHeader: weakOop) bitAnd: MarkBit) = 0].					oopGone ifTrue: ["Store nil in the pointer and signal the  interpreter "							self longAt: oop + i put: nilObj.							self signalFinalization: oop]]]! !!ObjectMemory methodsFor: 'object enumeration' stamp: 'dtl 4/22/2007 20:46'!accessibleObjectAfter: oop 	"Return the accessible object following the given object or 	free chunk in the heap. Return nil when heap is exhausted."	| obj |	self inline: false.	obj := self objectAfter: oop.	[self oop: obj isLessThan: endOfMemory]		whileTrue: [(self isFreeObject: obj) ifFalse: [^ obj].			obj := self objectAfter: obj].	^ nil! !!ObjectMemory methodsFor: 'object enumeration' stamp: 'dtl 4/22/2007 21:19'!firstAccessibleObject	"Return the first accessible object in the heap."	| obj |	obj := self firstObject.	[self oop: obj isLessThan: endOfMemory]		whileTrue: [(self isFreeObject: obj) ifFalse: [^ obj].			obj := self objectAfter: obj].	self error: 'heap is empty'! !!ObjectMemory methodsFor: 'object enumeration' stamp: 'dtl 4/22/2007 20:09'!objectAfter: oop 	"Return the object or free chunk immediately following the 	given object or free chunk in memory. Return endOfMemory 	when enumeration is complete."	| sz |	self inline: true.	DoAssertionChecks		ifTrue: [(self oop: oop isGreaterThanOrEqualTo:endOfMemory)					ifTrue: [self error: 'no objects after the end of memory']].	(self isFreeObject: oop)		ifTrue: [sz := self sizeOfFree: oop]		ifFalse: [sz := self sizeBitsOf: oop].	^ self oopFromChunk: oop + sz! !!ObjectMemory methodsFor: 'initialization' stamp: 'dtl 4/22/2007 20:48'!adjustAllOopsBy: bytesToShift 	"Adjust all oop references by the given number of bytes. This 	is done just after reading in an image when the new base 	address of the object heap is different from the base address 	in the image."	"di 11/18/2000 - return number of objects found"	| oop totalObjects |	self inline: false.	bytesToShift = 0 ifTrue: [^300000].	"this is probably an improvement over the previous answer of 	nil, but maybe we should do the obejct counting loop and 	simply guard the adjustFieldsAndClass... with a bytesToShift 	= 0 ifFalse: ?"	totalObjects := 0.	oop := self firstObject.	[self oop: oop isLessThan: endOfMemory]		whileTrue:			[(self isFreeObject: oop)				ifFalse:					[totalObjects := totalObjects + 1.					 self adjustFieldsAndClassOf: oop by: bytesToShift].			 oop := self objectAfter: oop].	^totalObjects! !!ObjectMemory methodsFor: 'initialization' stamp: 'dtl 4/22/2007 17:25'!adjustFieldsAndClassOf: oop by: offsetBytes 	"Adjust all pointers in this object by the given offset."	| fieldAddr fieldOop classHeader newClassOop |	self inline: true.	offsetBytes = 0 ifTrue: [^nil].	fieldAddr := oop + (self lastPointerOf: oop).	[self oop: fieldAddr isGreaterThan: oop]		whileTrue: [fieldOop := self longAt: fieldAddr.			(self isIntegerObject: fieldOop)				ifFalse: [self longAt: fieldAddr put: fieldOop + offsetBytes].			fieldAddr := fieldAddr - BytesPerWord].	(self headerType: oop) ~= HeaderTypeShort		ifTrue: ["adjust class header if not a compact class"			classHeader := self longAt: oop - BytesPerWord.			newClassOop := (classHeader bitAnd: AllButTypeMask) + offsetBytes.			self longAt: oop - BytesPerWord put: (newClassOop bitOr: (classHeader bitAnd: TypeMask))]! !!ObjectMemory methodsFor: 'initialization' stamp: 'dtl 4/22/2007 19:53'!initializeMemoryFirstFree: firstFree 	"Initialize endOfMemory to the top of oop storage space, reserving some space for forwarding blocks, and create the freeBlock from which space is allocated. Also create a fake free chunk at endOfMemory to act as a sentinal for memory scans. "	"Note: The amount of space reserved for forwarding blocks should be chosen to ensure that incremental compactions can usually be done in a single pass. However, there should be enough forwarding blocks so a full compaction can be done in a reasonable number of passes, say ten. (A full compaction requires N object-moving passes, where N = number of non-garbage objects / number of forwarding blocks). 	di 11/18/2000 Re totalObjectCount: Provide a margin of one byte per object to be used for forwarding pointers at GC time. Since fwd blocks are 8 bytes, this means an absolute worst case of 8 passes to compact memory. In most cases it will be adequate to do compaction in a single pass. "	| fwdBlockBytes |	"reserve space for forwarding blocks"	fwdBlockBytes := totalObjectCount bitAnd: WordMask - BytesPerWord + 1.	(self oop: memoryLimit - fwdBlockBytes isGreaterThanOrEqualTo: firstFree + BaseHeaderSize)		ifFalse: ["reserve enough space for a minimal free block of BaseHeaderSize bytes"			fwdBlockBytes := memoryLimit - (firstFree + BaseHeaderSize)].	"set endOfMemory and initialize freeBlock"	endOfMemory := memoryLimit - fwdBlockBytes.	freeBlock := firstFree.	self setSizeOfFree: freeBlock to: endOfMemory - firstFree. "bytes available for oops"	"make a fake free chunk at endOfMemory for use as a sentinel in memory scans"	self setSizeOfFree: endOfMemory to: BaseHeaderSize.	DoAssertionChecks		ifTrue: [(freeBlock < endOfMemory and: [endOfMemory < memoryLimit])				ifFalse: [self error: 'error in free space computation'].			(self oopFromChunk: endOfMemory) = endOfMemory				ifFalse: [self error: 'header format must have changed'].			(self objectAfter: freeBlock) = endOfMemory				ifFalse: [self error: 'free block not properly initialized']]! !!ObjectMemory methodsFor: 'become' stamp: 'dtl 4/22/2007 20:53'!allYoung: array1 and: array2 	"Return true if all the oops in both arrays, and the arrays 	themselves, are in the young object space."	| fieldOffset |	(self oop: array1 isLessThan: youngStart)		ifTrue: [^ false].	(self oop: array2 isLessThan: youngStart)		ifTrue: [^ false].	fieldOffset := self lastPointerOf: array1.	"same size as array2"	[fieldOffset >= BaseHeaderSize] whileTrue:		[(self oop: (self longAt: array1 + fieldOffset) isLessThan: youngStart)			ifTrue: [^ false].		(self oop: (self longAt: array2 + fieldOffset) isLessThan: youngStart)			ifTrue: [^ false].		fieldOffset := fieldOffset - BytesPerWord].	^ true! !!ObjectMemory methodsFor: 'become' stamp: 'dtl 4/22/2007 21:34'!restoreHeadersAfterForwardBecome: copyHashFlag 	"Forward become leaves us with no original oops in the 	mutated object list, 	so we must enumerate the (four-word) forwarding blocks 	where we have stored backpointers."	"This loop start is copied from fwdTableInit:"	| oop1 fwdBlock oop2 hdr1 hdr2 |	fwdBlock := endOfMemory + BaseHeaderSize + 7 bitAnd: WordMask - 7.	self flag: #Dan.  "See flag comment in fwdTableInit: (dtl)"	fwdBlock := fwdBlock + (BytesPerWord*4).	"fwdBlockGet: did a pre-increment"	[self oop: fwdBlock isLessThanOrEqualTo: fwdTableNext	"fwdTableNext points to the last active block"]		whileTrue: [oop1 := self longAt: fwdBlock + (BytesPerWord*2).			"Backpointer to mutated object."			oop2 := self longAt: fwdBlock.			self restoreHeaderOf: oop1.			copyHashFlag				ifTrue: ["Change the hash of the new oop (oop2) to be that of the old (oop1) 					so mutated objects in hash structures will be 					happy after the change."					hdr1 := self longAt: oop1.					hdr2 := self longAt: oop2.					self longAt: oop2 put: ((hdr2 bitAnd: AllButHashBits) bitOr: (hdr1 bitAnd: HashBits))].			fwdBlock := fwdBlock + (BytesPerWord*4)]! !!ObjectMemory methodsFor: 'allocation' stamp: 'dtl 4/22/2007 21:04'!allocateChunk: byteSize 	"Allocate a chunk of the given size. Sender must be sure that  the requested size includes enough space for the header  word(s). " 	"Details: To limit the time per incremental GC, do one every so many allocations. The number is settable via primitiveVMParameter to tune your memory system"	| enoughSpace newFreeSize newChunk |	self inline: true.	allocationCount >= allocationsBetweenGCs		ifTrue: ["do an incremental GC every so many allocations to  keep pauses short"			self incrementalGC].	enoughSpace := self sufficientSpaceToAllocate: byteSize.	enoughSpace		ifFalse: ["signal that space is running low, but proceed with allocation if possible"			signalLowSpace := true.			lowSpaceThreshold := 0. "disable additional interrupts until lowSpaceThreshold is reset by image"			self saveProcessSignalingLowSpace.			self forceInterruptCheck].	(self oop: (self sizeOfFree: freeBlock) isLessThan: byteSize + BaseHeaderSize)		ifTrue: [self error: 'out of memory'].	"if we get here, there is enough space for allocation to  succeed "	newFreeSize := (self sizeOfFree: freeBlock) - byteSize.	newChunk := freeBlock.	freeBlock := freeBlock + byteSize.	"Assume: client will initialize object header of free chunk, so following is not needed:"	"self setSizeOfFree: newChunk to: byteSize."	self setSizeOfFree: freeBlock to: newFreeSize.	allocationCount := allocationCount + 1.	^newChunk! !!ObjectMemory methodsFor: 'allocation' stamp: 'dtl 4/22/2007 21:10'!clone: oop	"Return a shallow copy of the given object. May cause GC"	"Assume: Oop is a real object, not a small integer."	| extraHdrBytes bytes newChunk remappedOop fromIndex toIndex lastFrom newOop header hash |	self inline: false.	self var: #lastFrom type: 'usqInt'.	self var: #fromIndex type: 'usqInt'.	extraHdrBytes := self extraHeaderBytes: oop.	bytes := self sizeBitsOf: oop.	bytes := bytes + extraHdrBytes.	"allocate space for the copy, remapping oop in case of a GC"	self pushRemappableOop: oop.	"check it is safe to allocate this much memory. Return 0 if not"	(self sufficientSpaceToAllocate: 2500 + bytes) ifFalse:[^0].	newChunk := self allocateChunk: bytes.	remappedOop := self popRemappableOop.	"copy old to new including all header words"	toIndex := newChunk - BytesPerWord.  "loop below uses pre-increment"	fromIndex := (remappedOop - extraHdrBytes) - BytesPerWord.	lastFrom := fromIndex + bytes.	[fromIndex < lastFrom] whileTrue: [		self longAt: (toIndex := toIndex + BytesPerWord) put: (self longAt: (fromIndex := fromIndex + BytesPerWord))].	newOop := newChunk + extraHdrBytes.  "convert from chunk to oop"	"fix base header: compute new hash and clear Mark and Root bits"	hash := self newObjectHash.	header := (self longAt: newOop) bitAnd: 16r1FFFF.	"use old ccIndex, format, size, and header-type fields"	header := header bitOr: ((hash << 17) bitAnd: 16r1FFE0000).	self longAt: newOop put: header.	^newOop! !!ObjectMemory methodsFor: 'allocation' stamp: 'dtl 4/22/2007 20:13'!recycleContextIfPossible: cntxOop 	"If possible, save the given context on a list of free contexts to 	be recycled."	"Note: The context is not marked free, so it can be reused 	with minimal fuss. The recycled context lists are cleared at 	every garbage collect."	| header |	self inline: true.	"only recycle young contexts (which should be most of them)"	(self oop: cntxOop isGreaterThanOrEqualTo: youngStart)		ifTrue: [header := self baseHeader: cntxOop.			(self isMethodContextHeader: header)				ifTrue: ["It's a young context, alright."					(header bitAnd: SizeMask) = SmallContextSize						ifTrue: ["Recycle small contexts"							self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeContexts.							freeContexts := cntxOop].					(header bitAnd: SizeMask) = LargeContextSize						ifTrue: ["Recycle large contexts"							self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeLargeContexts.							freeLargeContexts := cntxOop]]]! !!ObjectMemory methodsFor: 'allocation' stamp: 'dtl 4/22/2007 20:27'!sufficientSpaceAfterGC: minFree 	"Return true if there is enough free space after doing a garbage collection. If not, signal that space is low."	| growSize |	self inline: false.	self incrementalGC. "try to recover some space"	(self oop: (self sizeOfFree: freeBlock) isLessThan: minFree)		ifTrue: [signalLowSpace ifTrue: [^false]. "give up; problem is already noted"			self fullGC. "try harder"			"for stability, require more free space after doing an expensive full GC"			(self cCoerce: (self sizeOfFree: freeBlock) to: 'usqInt ') >= ((self cCoerce: minFree to: 'usqInt ') + 15000) ifTrue: [^ true].			"still not enough; attempt to grow object memory"			growSize := minFree - (self sizeOfFree: freeBlock) + growHeadroom.			self growObjectMemory: growSize.			(self oop: (self sizeOfFree: freeBlock) isGreaterThanOrEqualTo: minFree + 15000)				ifTrue: [^true].			"still not enough"			^false].	^true! !!ObjectMemory methodsFor: 'allocation' stamp: 'dtl 4/22/2007 20:28'!sufficientSpaceToAllocate: bytes	"Return true if there is enough space to allocate the given number of bytes, perhaps after doing a garbage collection."	| minFree |	self inline: true.	minFree := lowSpaceThreshold + bytes + BaseHeaderSize.	"check for low-space"	(self oop: (self sizeOfFree: freeBlock) isGreaterThanOrEqualTo: minFree)		ifTrue: [^true]		ifFalse: [^self sufficientSpaceAfterGC: minFree].! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'dtl 4/22/2007 21:05'!beRootIfOld: oop 	"If this object is old, mark it as a root (because a new object 	may be stored into it)"	self inline: false.	((self oop: oop isLessThan: youngStart)			and: [(self isIntegerObject: oop) not])		ifTrue: ["Yes, oop is an old object"			self noteAsRoot: oop headerLoc: oop]! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'dtl 4/22/2007 21:24'!lowestFreeAfter: chunk 	"Return the first free block after the given chunk in memory."	| oop oopHeader oopHeaderType oopSize |	self inline: false.	oop := self oopFromChunk: chunk.	[self oop: oop isLessThan: endOfMemory]		whileTrue: [oopHeader := self baseHeader: oop.			oopHeaderType := oopHeader bitAnd: TypeMask.			oopHeaderType = HeaderTypeFree				ifTrue: [^ oop]				ifFalse: [oopHeaderType = HeaderTypeSizeAndClass						ifTrue: [oopSize := (self sizeHeader: oop) bitAnd: AllButTypeMask]						ifFalse: [oopSize := oopHeader bitAnd: SizeMask]].			oop := self oopFromChunk: oop + oopSize].	self error: 'expected to find at least one free object'! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'dtl 4/22/2007 20:11'!possibleRootStoreInto: oop value: valueObj 	"oop is an old object. If valueObj is young, mark the object as a root."	self inline: false.	((self oop: valueObj isGreaterThanOrEqualTo: youngStart)			and: [(self isIntegerObject: valueObj) not])		ifTrue: ["Yes, valueObj is a young object"				self noteAsRoot: oop headerLoc: oop]! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'dtl 4/22/2007 20:36'!fwdBlockValidate: addr 	"Raise an error if the given address is not a valid forward table entry."	((self oop: addr isGreaterThan: endOfMemory)			and: [(self oop: addr isLessThanOrEqualTo: fwdTableNext)					and: [(addr bitAnd: 3) = 0]])		ifFalse: [self error: 'invalid fwd table entry']! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'dtl 4/22/2007 21:21'!incCompMakeFwd	"Create and initialize forwarding blocks for all non-free objects  	following compStart. If the supply of forwarding blocks is exhausted,  	set compEnd to the first chunk above the area to be 	compacted; otherwise, set it to endOfMemory. Return the number of 	bytes to be freed."	| bytesFreed oop fwdBlock newOop |	self inline: false.	bytesFreed := 0.	oop := self oopFromChunk: compStart.	[self oop: oop isLessThan: endOfMemory]		whileTrue: [				statMkFwdCount := statMkFwdCount + 1.				(self isFreeObject: oop)				ifTrue: [bytesFreed := bytesFreed + (self sizeOfFree: oop)]				ifFalse: ["create a forwarding block for oop"					fwdBlock := self fwdBlockGet: BytesPerWord*2.					"Two-word block"					fwdBlock = nil						ifTrue: ["stop; we have used all available forwarding blocks"							compEnd := self chunkFromOop: oop.							^ bytesFreed].					newOop := oop - bytesFreed.					self initForwardBlock: fwdBlock mapping: oop to: newOop withBackPtr: false].			oop := self objectAfterWhileForwarding: oop].	compEnd := endOfMemory.	^ bytesFreed! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'dtl 4/22/2007 21:21'!incCompMove: bytesFreed 	"Move all non-free objects between compStart and compEnd to their new  	locations, restoring their headers in the process. Create a new free  	block at the end of memory. Return the newly created free chunk. "	"Note: The free block used by the allocator always must be the last free  	block in memory. It may take several compaction passes to make all  	free space bubble up to the end of memory."	| oop next fwdBlock newOop header bytesToMove firstWord lastWord newFreeChunk sz target |	self inline: false.	newOop := nil.	oop := self oopFromChunk: compStart.	[self oop: oop isLessThan: compEnd]		whileTrue: [statCompMoveCount := statCompMoveCount + 1.			next := self objectAfterWhileForwarding: oop.			(self isFreeObject: oop)				ifFalse: ["a moving object; unwind its forwarding block"					fwdBlock := ((self longAt: oop) bitAnd: AllButMarkBitAndTypeMask) << 1.					DoAssertionChecks						ifTrue: [self fwdBlockValidate: fwdBlock].					newOop := self longAt: fwdBlock.					header := self longAt: fwdBlock + BytesPerWord.					self longAt: oop put: header. "restore the original header"					bytesToMove := oop - newOop. "move the oop (including any extra header words) "					sz := self sizeBitsOf: oop.					firstWord := oop - (self extraHeaderBytes: oop).					lastWord := oop + sz - BaseHeaderSize.					target := firstWord - bytesToMove.					firstWord to: lastWord by: BytesPerWord						do: [:w | 							self longAt: target put: (self longAt: w).							target := target + BytesPerWord]].			oop := next].	newOop = nil		ifTrue: ["no objects moved"			oop := self oopFromChunk: compStart.			((self isFreeObject: oop) and: [(self objectAfter: oop) = (self oopFromChunk: compEnd)])				ifTrue: [newFreeChunk := oop]				ifFalse: [newFreeChunk := freeBlock]]		ifFalse: ["initialize the newly freed memory chunk"			"newOop is the last object moved; free chunk starts 			right after it"			newFreeChunk := newOop + (self sizeBitsOf: newOop).			self setSizeOfFree: newFreeChunk to: bytesFreed].	DoAssertionChecks		ifTrue: [(self objectAfter: newFreeChunk) = (self oopFromChunk: compEnd)				ifFalse: [self error: 'problem creating free chunk after compaction']].	(self objectAfter: newFreeChunk) = endOfMemory		ifTrue: [self initializeMemoryFirstFree: newFreeChunk]		ifFalse: ["newFreeChunk is not at end of memory; re-install freeBlock "			self initializeMemoryFirstFree: freeBlock].	^ newFreeChunk! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'dtl 4/22/2007 20:17'!remapClassOf: oop 	"Update the class of the given object, if necessary, using its forwarding table entry."	"Note: Compact classes need not be remapped since the compact class field is just an index into the compact class 	table. The header type bits show if this object has a compact class; we needn't look up the oop's real header."	| classHeader classOop fwdBlock newClassOop newClassHeader |	(self headerType: oop) = HeaderTypeShort ifTrue: [^ nil]. "compact classes needn't be mapped"	classHeader := self longAt: oop - BytesPerWord.	classOop := classHeader bitAnd: AllButTypeMask.	(self isObjectForwarded: classOop)		ifTrue: [fwdBlock := ((self longAt: classOop) bitAnd: AllButMarkBitAndTypeMask) << 1.			DoAssertionChecks				ifTrue: [self fwdBlockValidate: fwdBlock].			newClassOop := self longAt: fwdBlock.			newClassHeader := newClassOop bitOr: (classHeader bitAnd: TypeMask).			self longAt: oop - BytesPerWord put: newClassHeader.			"The following ensures that become: into an old object's class makes it a root. 			It does nothing during either incremental or full compaction because 			oop will never be < youngStart."			((self oop: oop isLessThan: youngStart)					and: [self oop: newClassOop isGreaterThanOrEqualTo: youngStart])				ifTrue: [self beRootWhileForwarding: oop]]! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'dtl 4/22/2007 20:18'!remapFieldsAndClassOf: oop 	"Replace all forwarded pointers in this object with their new oops, using the forwarding table. Remap its class as well, if 	necessary. "	"Note: The given oop may be forwarded itself, which means that its real header is in its forwarding table entry."	| fieldOffset fieldOop fwdBlock newOop |	self inline: true.	fieldOffset := self lastPointerWhileForwarding: oop.	[fieldOffset >= BaseHeaderSize]		whileTrue: [fieldOop := self longAt: oop + fieldOffset.			(self isObjectForwarded: fieldOop)				ifTrue: ["update this oop from its forwarding block"					fwdBlock := ((self longAt: fieldOop) bitAnd: AllButMarkBitAndTypeMask) << 1.					DoAssertionChecks						ifTrue: [self fwdBlockValidate: fwdBlock].					newOop := self longAt: fwdBlock.					self longAt: oop + fieldOffset put: newOop.					"The following ensures that become: into old object makes it a root. 					It does nothing during either incremental or full compaction because 					oop will never be < youngStart."					((self oop: oop isLessThan: youngStart)							and: [self oop: newOop isGreaterThanOrEqualTo: youngStart])						ifTrue: [self beRootWhileForwarding: oop]].			fieldOffset := fieldOffset - BytesPerWord].	self remapClassOf: oop! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'dtl 4/22/2007 21:30'!updatePointersInRangeFrom: memStart to: memEnd 	"update pointers in the given memory range"	| oop |	self inline: false.	oop := self oopFromChunk: memStart.	[self oop: oop isLessThan: memEnd]		whileTrue: [(self isFreeObject: oop)				ifFalse: [self remapFieldsAndClassOf: oop].			oop := self objectAfterWhileForwarding: oop]! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'dtl 4/22/2007 20:31'!updatePointersInRootObjectsFrom: memStart to: memEnd 	"update pointers in root objects"	| oop |	self inline: false.	1 to: rootTableCount do: [:i | 			oop := rootTable at: i.			((self oop: oop isLessThan: memStart)					or: [self oop: oop isGreaterThanOrEqualTo: memEnd])				ifTrue: ["Note: must not remap the fields of any object twice!!"					"remap this oop only if not in the memory range 					covered below"					self remapFieldsAndClassOf: oop]]! !!ObjectMemory methodsFor: 'plugin support' stamp: 'dtl 4/22/2007 20:06'!isInMemory: address 	"Return true if the given address is in ST object memory"	^ (self oop: address isGreaterThanOrEqualTo: self startOfMemory)		and: [self oop: address isLessThan: endOfMemory]! !!ObjectMemory methodsFor: 'memory access' stamp: 'dtl 4/22/2007 18:33'!checkAddress: byteAddress 	"Keep this method around for debugging the C code."	(self oop: byteAddress isLessThan: self startOfMemory)		ifTrue: [self error: 'bad address: negative'].	(self oop: byteAddress isGreaterThanOrEqualTo: memoryLimit)		ifTrue: [self error: 'bad address: past end of heap']! !!ObjectMemory methodsFor: 'memory access' stamp: 'dtl 4/22/2007 18:24'!validateRoots 	"Verify that every old object that points to a new object 		has its root bit set, and		appears in the rootTable.	This method should not be called if the rootTable is full, because roots	are no longer recorded, and incremental collections are not attempted.	If DoAssertionChecks is true, this routine will halt on an unmarked root.	Otherwise, this routine will merely return true in that case."	| oop fieldAddr fieldOop header badRoot |	self var: #oop type: 'usqInt'.	self var: #fieldAddr type: 'usqInt'.	self var: #fieldOop type: 'usqInt'.	badRoot := false.	oop := self firstObject.	[oop < youngStart] whileTrue:		[(self isFreeObject: oop) ifFalse:			[fieldAddr := oop + (self lastPointerOf: oop).			[fieldAddr > oop] whileTrue:				[fieldOop := self longAt: fieldAddr.				(fieldOop >= youngStart and: [(self isIntegerObject: fieldOop) not]) ifTrue:					["fieldOop is a pointer to a young object"					header := self longAt: oop.					(header bitAnd: RootBit) = 0					ifTrue:						["Forbidden: points to young obj but root bit not set."						DoAssertionChecks ifTrue: [self error: 'root bit not set'].						badRoot := true]					ifFalse:						["Root bit is set"						"Extreme test -- validate that oop was entered in rootTable too..."						"Disabled for now...						found := false.						1 to: rootTableCount do:							[:i | oop = (rootTable at: i) ifTrue: [found := true]].						found ifFalse:							[DoAssertionChecks ifTrue: [self error: 'root table not set'].							badRoot := true].						..."						]].				fieldAddr := fieldAddr - BytesPerWord]].		oop := self objectAfter: oop].	^ badRoot! !!ObjectMemory methodsFor: 'interpreter access' stamp: 'dtl 4/22/2007 21:26'!storePointer: fieldIndex ofObject: oop withValue: valuePointer	"Note must check here for stores of young objects into old ones."	(self oop: oop isLessThan: youngStart) ifTrue: [		self possibleRootStoreInto: oop value: valuePointer.	].	^ self longAt: oop + BaseHeaderSize + (fieldIndex << ShiftForWord)		put: valuePointer! !