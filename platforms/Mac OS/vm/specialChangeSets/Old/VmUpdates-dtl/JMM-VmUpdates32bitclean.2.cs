'From Squeak3.8.1 of ''28 Aug 2006'' [latest update: #6747] on 9 June 2007 at 5:30:55 pm'!!ObjectMemory methodsFor: 'header access' stamp: 'JMM 6/9/2007 15:31'!sizeOfFree: oop	"Return the size of the given chunk in bytes. Argument MUST be a free chunk."	self returnTypeC: 'usqInt'.	^ (self longAt: oop) bitAnd: AllButTypeMask! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'JMM 6/9/2007 15:38'!incrementalGC	"Do a mark/sweep garbage collection of just the young object 	area of object memory (i.e., objects above youngStart), using 	the root table to identify objects containing pointers to 	young objects from the old object area."	| survivorCount startTime weDidGrow |	self inline: false.	rootTableCount >= RootTableSize		ifTrue: ["root table overflow; cannot do an incremental GC (this should be very rare)"			statRootTableOverflows := statRootTableOverflows + 1.			^ self fullGC].	DoAssertionChecks		ifTrue: [self reverseDisplayFrom: 8 to: 15.			self validateRoots; validate].	self preGCAction: false.	"incremental GC and compaction"	startTime := self ioMicroMSecs.	weakRootCount := 0.	statSweepCount := statMarkCount := statMkFwdCount := statCompMoveCount := 0.	self markPhase.	1 to: weakRootCount do:[:i| self finalizeReference: (weakRoots at: i)].	survivorCount := self sweepPhase.	self incrementalCompaction.	statAllocationCount := allocationCount.	allocationCount := 0.	statIncrGCs := statIncrGCs + 1.	statGCTime := self ioMicroMSecs.	statIGCDeltaTime := statGCTime - startTime.	statIncrGCMSecs := statIncrGCMSecs + statIGCDeltaTime.	self capturePendingFinalizationSignals.	self forceInterruptCheck. "Force an an interrupt check ASAP.We could choose to be clever here and only do this under certain time conditions. Keep it simple for now"		statRootTableCount  := rootTableCount.	statSurvivorCount := survivorCount.	weDidGrow := false.	(((survivorCount > tenuringThreshold)			or: [rootTableCount >= RootTableRedZone])			or: [forceTenureFlag == true])		ifTrue: ["move up the young space boundary if 			* there are too many survivors: 			this limits the number of objects that must be 			processed on future incremental GC's 			* we're about to overflow the roots table 			this limits the number of full GCs that may be caused 			by root table overflows in the near future"			forceTenureFlag := false.			statTenures := statTenures + 1.			self clearRootsTable.			(((self oop: (self sizeOfFree: freeBlock) isLessThan: growHeadroom)) and: 				[gcBiasToGrow > 0]) 				ifTrue: [self biasToGrow.						weDidGrow := true].			youngStart := freeBlock].	self postGCAction.	DoAssertionChecks		ifTrue: [self validateRoots; validate.			self reverseDisplayFrom: 8 to: 15].	weDidGrow ifTrue: [self biasToGrowCheckGCLimit]! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'JMM 6/9/2007 12:06'!incCompMove: bytesFreed 	"Move all non-free objects between compStart and compEnd to their new  	locations, restoring their headers in the process. Create a new free  	block at the end of memory. Return the newly created free chunk. "	"Note: The free block used by the allocator always must be the last free  	block in memory. It may take several compaction passes to make all  	free space bubble up to the end of memory."	| oop next fwdBlock newOop header bytesToMove firstWord lastWord newFreeChunk sz target |	self inline: false.	self var: #firstWord type: 'usqInt'.	self var: #lastWord type: 'usqInt'.	self var: #w type: 'usqInt'.	newOop := nil.	oop := self oopFromChunk: compStart.	[self oop: oop isLessThan: compEnd]		whileTrue: [statCompMoveCount := statCompMoveCount + 1.			next := self objectAfterWhileForwarding: oop.			(self isFreeObject: oop)				ifFalse: ["a moving object; unwind its forwarding block"					fwdBlock := ((self longAt: oop) bitAnd: AllButMarkBitAndTypeMask) << 1.					DoAssertionChecks						ifTrue: [self fwdBlockValidate: fwdBlock].					newOop := self longAt: fwdBlock.					header := self longAt: fwdBlock + BytesPerWord.					self longAt: oop put: header. "restore the original header"					bytesToMove := oop - newOop. "move the oop (including any extra header words) "					sz := self sizeBitsOf: oop.					firstWord := oop - (self extraHeaderBytes: oop).					lastWord := oop + sz - BaseHeaderSize.					target := firstWord - bytesToMove.					firstWord to: lastWord by: BytesPerWord						do: [:w | 							self longAt: target put: (self longAt: w).							target := target + BytesPerWord]].			oop := next].	newOop = nil		ifTrue: ["no objects moved"			oop := self oopFromChunk: compStart.			((self isFreeObject: oop) and: [(self objectAfter: oop) = (self oopFromChunk: compEnd)])				ifTrue: [newFreeChunk := oop]				ifFalse: [newFreeChunk := freeBlock]]		ifFalse: ["initialize the newly freed memory chunk"			"newOop is the last object moved; free chunk starts 			right after it"			newFreeChunk := newOop + (self sizeBitsOf: newOop).			self setSizeOfFree: newFreeChunk to: bytesFreed].	DoAssertionChecks		ifTrue: [(self objectAfter: newFreeChunk) = (self oopFromChunk: compEnd)				ifFalse: [self error: 'problem creating free chunk after compaction']].	(self objectAfter: newFreeChunk) = endOfMemory		ifTrue: [self initializeMemoryFirstFree: newFreeChunk]		ifFalse: ["newFreeChunk is not at end of memory; re-install freeBlock "			self initializeMemoryFirstFree: freeBlock].	^ newFreeChunk! !!Interpreter methodsFor: 'object memory support' stamp: 'JMM 6/9/2007 15:36'!postGCAction	"Mark the active and home contexts as roots if old. This 	allows the interpreter to use storePointerUnchecked to 	store into them."	compilerInitialized		ifTrue: [self compilerPostGC]		ifFalse: [(self oop: activeContext isLessThan: youngStart)				ifTrue: [self beRootIfOld: activeContext].			(self oop: theHomeContext isLessThan: youngStart)				ifTrue: [self beRootIfOld: theHomeContext]].	(self oop: (self sizeOfFree: freeBlock) isGreaterThan:  shrinkThreshold)		ifTrue: ["Attempt to shrink memory after successfully 			reclaiming lots of memory"			self shrinkObjectMemory: (self sizeOfFree: freeBlock) - growHeadroom].		self signalSemaphoreWithIndex: gcSemaphoreIndex.! !