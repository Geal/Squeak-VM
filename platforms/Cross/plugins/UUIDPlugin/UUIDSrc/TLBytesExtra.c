/*------------------------------------------------------------
| TLBytesExtra.c
|-------------------------------------------------------------
| 
| PURPOSE: To provide less commonly used byte-addressed memory 
|          functions.
|
| DESCRIPTION: 
|
| NOTE: 
|
| HISTORY: 05.29.01 from TLBytes.c.
------------------------------------------------------------*/

#include "TLTarget.h" 

#include <stdio.h>
#include <string.h> // For 'memset()'.
#include <stdlib.h>

#include "NumTypes.h"
#include "TLBytes.h"
#include "TLLog.h"

#include "TLBytesExtra.h"


u32 CountOfBytesParsed; // Result count

/*------------------------------------------------------------
| CRC32Table
|-------------------------------------------------------------
|
| PURPOSE: To hold values used to calculate 32-bit CRC values.
|
| DESCRIPTION: This table holds the same values generated
| by using 'BuildCRC32Table()'.
|
| WARNING: While this CRC32 uses the same polynomial as that
| of the MPEG2 section CRC_32 it DOES NOT compute the values
| required by MPEG2.
|
| Here is some additional commentary on this particular
| CRC that was found on the web at http://www.brokersys.com/snippets
|
| "...[This] 32-bit CRC is used as the frame check sequence in 
| ADCCP (ANSI X3.66, also known as FIPS PUB 71 and FED-STD-1003, 
| the U.S. versions of CCITT's X.25 link-level protocol).  
|
| The 32-bit FCS was added via the Federal Register, 1 June 
| 1982, p.23798.  I presume but don't know for certain that    
| this polynomial is or will be included in CCITT V.41, which 
| defines the 16-bit CRC (often called CRC-CCITT) polynomial.  
| FIPS PUB 78 says that the 32-bit FCS reduces otherwise 
| undetected errors by a factor of 10^-5 over 16-bit FCS."
|
| "Copyright (C) 1986 Gary S. Brown.  You may use this program,
| or code or tables extracted from it, as desired without 
| restriction. 
|
| First, the polynomial itself and its table of feedback terms.  
| The polynomial is
|
|   32  26  23  22  16  12  11  10  8   7   5   4   2   1   0
|  x + x + x + x + x + x + x + x + x + x + x + x + x + x + x
|
| Note that we take it "backwards" and put the highest-order 
| term in the lowest-order bit.  The X^32 term is "implied"; 
| the LSB is the X^31 term, etc.  The X^0 term (usually shown 
| as "+1") results in the MSB being 1. 
|
| Note that the usual hardware shift register implementation, 
| which is what we're using (we're merely optimizing it by 
| doing eight-bit chunks at a time) shifts bits into the 
| lowest-order term.  In our implementation, that means 
| shifting towards the right.  
|
| Why do we do it this way?  
|
| Because the calculated CRC must be transmitted in order from 
| highest-order term to lowest-order term.  UARTs transmit  
| characters in order from LSB to MSB.  By storing the CRC 
| this way, we hand it to the UART in the order low-byte to 
| high-byte; the UART sends each low-bit to hight-bit; and 
| the result is transmission bit by bit from highest- to 
| lowest-order term without requiring any bit  shuffling on 
| our part.  Reception works similarly.  
|
| The feedback terms table consists of 256, 32-bit entries.  
|
|   1. The table can be generated at runtime if desired; code 
|      to do so is shown later.  It might not be obvious, but 
|      the feedback terms simply represent the results of 
|      eight shift/xor operations for all combinations of data 
|      and CRC register values. 
|
|   2. The CRC accumulation logic is the same for all CRC 
|      polynomials, be they sixteen or thirty-two bits wide.  
|      You simply choose the appropriate table.  Alternatively, 
|      because the table can be generated at runtime, you can 
|      start by generating the table for the polynomial in 
|      question and use exactly the same "updcrc", if your 
|      application needn't simultaneously handle two CRC        
|      polynomials.  (Note, however, that XMODEM is strange.)  
|
|   3. For 16-bit CRCs, the table entries need be only 16 bits 
|      wide; of course, 32-bit entries work OK if the high 16 
|      bits are zero. 
|
|   4. The values must be right-shifted by eight bits by the 
|      "updcrc" logic; the shift must be unsigned (bring in 
|      zeroes).  On some hardware you could probably optimize 
|      the shift in assembler by using byte-swap instructions.
|
| HISTORY: 01.09.99 Compared to results generated by
|                   'BuildCRC32Table()' and by
|                   'make_crc_table()' from zlib -- all
|                   results matched properly.
|
|          03.22.00 Added polynomial specification and
|                   commentary and mistakenly concluded
|                   that the MPEG2 CRC is the same one
|                   as this one.  It isn't.
------------------------------------------------------------*/
u32 
CRC32Table[256] = 
{
    0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 
    0x076dc419L, 0x706af48fL, 0xe963a535L, 0x9e6495a3L, 
    0x0edb8832L, 0x79dcb8a4L, 0xe0d5e91eL, 0x97d2d988L, 
    0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L, 0x90bf1d91L, 
    0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
    0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 
    0x136c9856L, 0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 
    0x14015c4fL, 0x63066cd9L, 0xfa0f3d63L, 0x8d080df5L, 
    0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L, 0xa2677172L, 
    0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
    0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 
    0x32d86ce3L, 0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 
    0x26d930acL, 0x51de003aL, 0xc8d75180L, 0xbfd06116L, 
    0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L, 0xb8bda50fL, 
    0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
    0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 
    0x76dc4190L, 0x01db7106L, 0x98d220bcL, 0xefd5102aL, 
    0x71b18589L, 0x06b6b51fL, 0x9fbfe4a5L, 0xe8b8d433L, 
    0x7807c9a2L, 0x0f00f934L, 0x9609a88eL, 0xe10e9818L, 
    0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
    0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 
    0x6c0695edL, 0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 
    0x65b0d9c6L, 0x12b7e950L, 0x8bbeb8eaL, 0xfcb9887cL, 
    0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L, 0xfbd44c65L, 
    0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
    0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 
    0x4369e96aL, 0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 
    0x44042d73L, 0x33031de5L, 0xaa0a4c5fL, 0xdd0d7cc9L, 
    0x5005713cL, 0x270241aaL, 0xbe0b1010L, 0xc90c2086L, 
    0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
    0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 
    0x59b33d17L, 0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 
    0xedb88320L, 0x9abfb3b6L, 0x03b6e20cL, 0x74b1d29aL, 
    0xead54739L, 0x9dd277afL, 0x04db2615L, 0x73dc1683L, 
    0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
    0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 
    0xf00f9344L, 0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 
    0xf762575dL, 0x806567cbL, 0x196c3671L, 0x6e6b06e7L, 
    0xfed41b76L, 0x89d32be0L, 0x10da7a5aL, 0x67dd4accL, 
    0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
    0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 
    0xd1bb67f1L, 0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 
    0xd80d2bdaL, 0xaf0a1b4cL, 0x36034af6L, 0x41047a60L, 
    0xdf60efc3L, 0xa867df55L, 0x316e8eefL, 0x4669be79L, 
    0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
    0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 
    0xc5ba3bbeL, 0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 
    0xc2d7ffa7L, 0xb5d0cf31L, 0x2cd99e8bL, 0x5bdeae1dL, 
    0x9b64c2b0L, 0xec63f226L, 0x756aa39cL, 0x026d930aL, 
    0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
    0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 
    0x92d28e9bL, 0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 
    0x86d3d2d4L, 0xf1d4e242L, 0x68ddb3f8L, 0x1fda836eL, 
    0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L, 0x18b74777L, 
    0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
    0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 
    0xa00ae278L, 0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 
    0xa7672661L, 0xd06016f7L, 0x4969474dL, 0x3e6e77dbL, 
    0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L, 0x37d83bf0L, 
    0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
    0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 
    0xbad03605L, 0xcdd70693L, 0x54de5729L, 0x23d967bfL, 
    0xb3667a2eL, 0xc4614ab8L, 0x5d681b02L, 0x2a6f2b94L, 
    0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL, 0x2d02ef8dL
};

/*------------------------------------------------------------
| ABAddBytes
|-------------------------------------------------------------
|
| PURPOSE: To add two ranges of bytes to store at a third.
|
| DESCRIPTION:  
|
| EXAMPLE: 
|
| NOTE: 
|
| ASSUMES: One of the sources may also be the destination. 
|
| HISTORY:  01.24.97
------------------------------------------------------------*/
void
ABAddBytes( u8* SrcA, u8* SrcB, u8* Dst, u32 Count )
{
    while( Count-- )
    {
        *Dst++ = (u8) ( (*SrcA++) + (*SrcB++) );
    }
}

/*------------------------------------------------------------
| ABBlendBytes
|-------------------------------------------------------------
|
| PURPOSE: To blend a two ranges of bytes using mass weights.
|
| DESCRIPTION:  
|
|  Blend(SrcA,MassA,SrcB,MassB,MaxMass) = 
|   if( (MassA+MassB)<=MaxMass, 
|       (SrcA*MassA)/(MassA+MassB) + 
|       (SrcB*MassB)/(MassA+MassB), 
|       Blend( SrcA,
|              (MassA/(MassA+MassB)) * MaxMass, 
|              SrcB, 
|              (MassB/(MassA+MassB)) * MaxMass, 
|              MaxMass) ) --> Dst
|
| BlendMass( MassA, MassB, MassMax ) = 
|    if( (MassA+MassB) <= MassMax, (MassA+MassB), MassMax ) 
|       --> MassDst
|
| EXAMPLE:  ABBlendBytes( SrcA, SrcAMass, 
|                         SrcB, SrcBMass, 
|                         Dst, DstMass, 
|                         MaxMass, (u32) 5 );
|
| ASSUMES: Overlap case is undefined.
|
| HISTORY: 01.27.97 from 'CopyBytes'.
------------------------------------------------------------*/
void
ABBlendBytes( u8* SrcA, u8* SrcAMass,
              u8* SrcB, u8* SrcBMass, 
              u8* Dst,  u8* DstMass, 
              u32 MaxMass, u32 Count )
{
    u32 A, a, B, b, ab;
    u8  D;
    
    while( Count-- )
    {
        A = (u32) *SrcA++;
        a = (u32) *SrcAMass++;
        B = (u32) *SrcB++;
        b = (u32) *SrcBMass++;
        
        // Sum the mass.
        ab = a+b;
        
        // If there is any mass.
        if( ab )
        {
            // If the mass exceeds the limit.
            if( ab > MaxMass )
            {
                // Rescale the masses.
                a = (a/ab) * MaxMass;
                b = (b/ab) * MaxMass;
                ab = MaxMass;
            }
            
            // Blend the parts.
            D = (u8) ( ( (A*a) + (B*b) ) / ab );
        }
        else
        {
            D = 0;
        }
        
        // Save the result.
        *Dst++ = D;
        *DstMass++ = (u8) ab;
    }
}

/*------------------------------------------------------------
| ABMultBytes
|-------------------------------------------------------------
|
| PURPOSE: To multiply two ranges of bytes to store at a third.
|
| DESCRIPTION:  
|
| EXAMPLE: 
|
|
| NOTE: 
|
| ASSUMES: One of the sources may also be the destination. 
|
| HISTORY:  01.24.97
------------------------------------------------------------*/
void
ABMultBytes( u8* SrcA, u8* SrcB, u8* Dst, u32 Count )
{
    while( Count-- )
    {
        *Dst++ = (u8) ( (*SrcA++) * (*SrcB++) );
    }
}

/*------------------------------------------------------------
| ABOrBytes
|-------------------------------------------------------------
|
| PURPOSE: To OR two ranges of bytes to store at a third.
|
| DESCRIPTION:  
|
| EXAMPLE: 
|
|
| NOTE: 
|
| ASSUMES: One of the sources may also be the destination. 
|
| HISTORY:  01.24.97
------------------------------------------------------------*/
void
ABOrBytes( u8* SrcA, u8* SrcB, u8* Dst, u32 Count )
{
    while( Count-- )
    {
        *Dst++ = (u8) ( *SrcA++ | *SrcB++ );
    }
}

/*------------------------------------------------------------
| ABUnblendBytes
|-------------------------------------------------------------
|
| PURPOSE: To unblend a two ranges of bytes using mass 
|          weights.
|
| DESCRIPTION:  
|
|  Unblend(SrcA,MassA,SrcB,MassB,MaxMass) = 
|   if( (-MassA+MassB) > 0, 
|       (SrcA*-MassA)/(-MassA+MassB) + 
|       (SrcB*MassB)/(-MassA+MassB), 
|       0 ) --> Dst
|
| UnblendMass( MassA, MassB, MassMax ) = 
|    if( (MassA+MassB) <= MassMax, (MassA+MassB), MassMax ) 
|       --> MassDst
|
| EXAMPLE:  ABUnblendBytes( SrcA, SrcAMass, 
|                           SrcB, SrcBMass, 
|                           Dst, DstMass, 
|                           (u32) 5 );
|
| NOTE: Blend/Unblend are reversible as long as the maximum
|       mass limit isn't reached.
|
| ASSUMES: Overlap case is undefined.
|
| HISTORY: 01.27.97 from 'ABBlendBytes'.
------------------------------------------------------------*/
void
ABUnblendBytes( u8* SrcA, u8* SrcAMass,
              u8* SrcB, u8* SrcBMass, 
              u8* Dst,  u8* DstMass, 
              u32 Count )
{
    s32 A, a, B, b, ab, x;
    u8  D;
    
    while( Count-- )
    {
        A = (s32) *SrcA++;
        a = (s32) *SrcAMass++;
        B = (s32) *SrcB++;
        b = (s32) *SrcBMass++;
        
        // Deduct the 'a' mass.
        ab = b-a;
        
        // If there is any mass.
        if( ab > 0 )
        {
            // Unblend the 'A' part.
            x = ( ( (B*b) - (A*a) ) / ab );
            
            if( x > 0 )
            {
                D = (u8) x;
            }
            else
            {
                D = 0;
            }
        }
        else
        {
            ab = 0;
            D = 0;
        }
        
        // Save the result.
        *Dst++ = D;
        *DstMass++ = (u8) ab;
    }
}

/*------------------------------------------------------------
| ABXorBytes
|-------------------------------------------------------------
|
| PURPOSE: To XOR two ranges of bytes to store at a third.
|
| DESCRIPTION:  
|
| EXAMPLE: 
|
|
| NOTE: 
|
| ASSUMES: One of the sources may also be the destination. 
|
| HISTORY:  01.24.97
------------------------------------------------------------*/
void
ABXorBytes( u8* SrcA, u8* SrcB, u8* Dst, u32 Count )
{
    while( Count-- )
    {
        *Dst++ = (u8) ( *SrcA++ ^ *SrcB++ );
    }
}

/*------------------------------------------------------------
| AddToBytes
|-------------------------------------------------------------
|
| PURPOSE: To add a constant value to a series of bytes.
|
| DESCRIPTION:  
|
| EXAMPLE:  AddToBytes( Buf, Count, (u32) 5 );
|
| NOTE: 
|
| ASSUMES: 
|
| HISTORY: 08.04.98
------------------------------------------------------------*/
void
AddToBytes( u8* Buf, u32 Count, u32 Displacement )
{
    while( Count-- )
    {
        *Buf++ += (u8) Displacement;
    }
}

/*------------------------------------------------------------
| AndBytes
|-------------------------------------------------------------
|
| PURPOSE: To and a range of bytes to another.
|
| DESCRIPTION: Correctly handles overlapping series of bytes. 
|
| EXAMPLE:  AndBytes( From, To, (u32) 5 );
|
| NOTE: This could be sped up by moving 32-bit chunks where
|       possible.
|
| ASSUMES: 
|
| HISTORY: 01.22.97
------------------------------------------------------------*/
void
AndBytes( u8* From, u8* To, u32 Count )
{
    if( From >= To )
    {
        while( Count-- )
        {
            *To++ &= *From++;
        }
    }
    else
    {
        To   += Count;
        From += Count;
        
        while( Count-- )
        {
            *--To &= *--From;
        }
    }
}

/*------------------------------------------------------------
| AndBytesTwoSrc
|-------------------------------------------------------------
|
| PURPOSE: To AND two ranges of bytes to store at a third.
|
| DESCRIPTION:  
|
| EXAMPLE: 
|
|
| NOTE: 
|
| ASSUMES: One of the sources may also be the destination. 
|
| HISTORY:  12.26.95
------------------------------------------------------------*/
void
AndBytesTwoSrc( u8* SrcA, u8* SrcB, u8* Dst, u32 Count )
{
    while( Count-- )
    {
        *Dst++ = (u8) ( *SrcA++ & *SrcB++ );
    }
}

/*------------------------------------------------------------
| BuildCRC32Table
|-------------------------------------------------------------
|
| PURPOSE: To make a data table used by 'CRC32Byte'.
|
| DESCRIPTION: Builds the coefficient table used to calculate
| 32 bit CRC values.
|
| See also "C Programmer's Guide to Serial Communications"
| by Joe Campbell for a good explanation of CRC math.
|
| EXAMPLE:     
|
| NOTES: This routine must be run sometime before 'CRC32Bytes'
|        is called.
|
| ASSUMES:  
|
| HISTORY: 07.24.96 from 'The Data Compression Book' p. 416.
------------------------------------------------------------*/
void
BuildCRC32Table()
{
    s32 i;
    s32 j;
    u32 value;

    for( i = 0; i <= 255 ; i++ ) 
    {
        value = (u32) i;
        
        for( j = 8 ; j > 0; j-- ) 
        {
            if( value & 1 )
            {
                value = ( value >> 1 ) ^ 0xEDB88320L;
            }
            else
            {
                value >>= 1;
            }
        }
        
        CRC32Table[i] = value;
    }
}

/*------------------------------------------------------------
| BytesToUint16
|-------------------------------------------------------------
|
| PURPOSE: To convert two bytes ordered LSB:MSB to a u16.
|
| DESCRIPTION: Different CPUs organize memory in different 
| ways.  This procedure is used to allow communication of
| u16-size data from one computer to another.
|
| EXAMPLE:  Au16 = BytesToUint16(ABuffer);
|
|
| NOTE: 
|
| ASSUMES: 
|
| HISTORY:  03.12.94 
------------------------------------------------------------*/
u16
BytesToUint16( u8* AtBytes )
{
    u16 Result;
    
    Result = (u16) AtBytes[0];
    
    Result |= (u16) ( ((u16) AtBytes[1]) << 8 );
    
    return( Result );
}
    
/*------------------------------------------------------------
| BytesToUint32
|-------------------------------------------------------------
|
| PURPOSE: To convert four bytes ordered LSB->MSB to a u32.
|
| DESCRIPTION: Different CPUs organize memory in different 
| ways.  This procedure is used to allow communication of
| u32-size data from one computer to another.
|
| EXAMPLE:  Au32 = BytesToUint32(ABuffer);
|
|
| NOTE: 
|
| ASSUMES: 
|
| HISTORY:  03.12.94 
------------------------------------------------------------*/
u32
BytesToUint32(u8* AtBytes)
{
    u32 Result;
    
    Result = (u32) AtBytes[0];
    
    Result |= ((u32) AtBytes[1]) << 8;

    Result |= ((u32) AtBytes[2]) << 16;

    Result |= ((u32) AtBytes[3]) << 24;
    
    return(Result);
}

/*------------------------------------------------------------
| CopyInverseBytes
|-------------------------------------------------------------
|
| PURPOSE: To copy a range of bytes from one place 
|          to another, inverting them in the process.
|
| DESCRIPTION: Correctly handles overlapping series of bytes. 
|
| EXAMPLE:  CopyInverseBytes( From, To, (u32) 5 );
|
| NOTE: You must cast literal count parameters to be a 'u32' 
|       to avoid errors. 
|
|       This could be sped up by moving 32-bit chunks where
|       possible.
|
| ASSUMES: 
|
| HISTORY: 01.24.97 from 'CopyBytes'.
------------------------------------------------------------*/
void
CopyInverseBytes( u8* From, u8* To, u32 Count )
{
    if( From >= To )
    {
        while( Count-- )
        {
            *To++ = (u8) ~(*From++);
        }
    }
    else
    {
        To   += Count;
        From += Count;
        
        while( Count-- )
        {
            *--To = (u8) ~(*--From);
        }
    }
}

/*------------------------------------------------------------
| CopyObjectBytes
|-------------------------------------------------------------
|
| PURPOSE: To copy a range of bytes defined by an object mask
|          from one place to another.
|
| DESCRIPTION: Correctly handles overlapping series of bytes. 
|
| Augments the destination mask with the source mask.
|
| EXAMPLE:  CopyObjectBytes( From, FromMask, 
|                            To, ToMask, (u32) 5 );
|
| ASSUMES: 
|
| HISTORY: 01.27.97 from 'CopyBytes'.
------------------------------------------------------------*/
void
CopyObjectBytes( u8* Src, u8* SrcMask, 
                 u8* Dst, u8* DstMask, u32 Count )
{
    u8  A, M, D;
    
    if( Src >= Dst )
    {
        while( Count-- )
        {
            A = *Src++;
            M = *SrcMask++;
            D = *Dst;
            
            *Dst++ = (u8) ( (A & M) | (~M & D) );
            *DstMask++ |= M;
        }
    }
    else // Travel high-to-low.
    {
        Src     += Count;
        SrcMask += Count;
        Dst     += Count;
        DstMask += Count;
        
        while( Count-- )
        {
            A = *--Src;
            M = *--SrcMask;
            D = *--Dst;
            
            *Dst = (u8) ( (A & M) | (~M & D) );
            *--DstMask |= M;
        }
    }
}

/*------------------------------------------------------------
| CRC32Byte
|-------------------------------------------------------------
|
| PURPOSE: To compute the cyclic-redundancy check value for
| a byte combined with a given 32 bit CRC value.
|
| DESCRIPTION: 
|
| EXAMPLE:     
|
| NOTES:   
|
| ASSUMES: 'BuildCRC32Table' run before this is called.
|
| HISTORY: 07.24.96 from 'The Data Compression Book' p. 416.
------------------------------------------------------------*/
u32
CRC32Byte( u32 CRC, u16 AByte )
{
    u32 a;
    u32 b;

    a = ( CRC >> 8 ) & 0x00FFFFFFL;
    b = CRC32Table[ ( CRC ^ AByte ) & 0xff ];
    CRC = a ^ b;
 
    return(CRC);
}

/*------------------------------------------------------------
| CRC32Bytes
|-------------------------------------------------------------
|
| PURPOSE: To update a running crc with the bytes in a buffer 
|          and return the updated crc. 
|
| DESCRIPTION: Computes the CRC-32 used by the Ethernet and
| zlib standards.
|
| Use an initial value of 0 if no bytes have been 
| accumulated.
|
| Pre- and post-conditioning using one's complement is 
| performed within this function so it shouldn't be done by 
| the application.  This is done to close a blind-spot in 
| the algorithm where multiple leading zero bytes are not 
| registered.
|
| For a best explanation of CRC theory see 
|       ftp.adelaide.edu.au/pub/rocksoft/crc_v3.txt
| by Ross N.Williams.
|
| See also "C Programmer's Guide to Serial Communications"
| by Joe Campbell for a good explanation of CRC math and 
| example polynomial math algorithms.
|
| EXAMPLE:     
|
|   u32 crc = 0;
|
|   while( read_buffer( buffer, length ) != EOF ) 
|   {
|       crc = CRC32Bytes( buffer, length, crc );
|   }
|
|   if( crc != original_crc ) error();
|
| NOTES:   
|
| ASSUMES:
|
| HISTORY: 07.24.96 from 'CRCBytes' and routine from
|                   'The Data Compression Book' p. 416.
|          01.09.99 Revised to use compile-time built
|                   CRC table and the unrolled loop method
|                   from 'crc32.c' by Mark Adler, part of 
|                   zlib.
------------------------------------------------------------*/
u32
CRC32Bytes( u8* buf, u32 HowManyBytes, u32 CRC )
{
    // One's complement the initial value to close a 
    // blind-spot in the algorithm where multiple leading
    // zero bytes are not registered.
    CRC = CRC ^ 0xFFFFFFFFL;
    
    // As long as eight or more bytes remain to be processed.
    while( HowManyBytes >= 8 )
    {
        // Update the CRC value for eight consecutive bytes.
        CRC = CRC32Table[ ((s8)CRC ^ (*buf++)) & 0xFF ] ^ (CRC >> 8);
        CRC = CRC32Table[ ((s8)CRC ^ (*buf++)) & 0xFF ] ^ (CRC >> 8);
        CRC = CRC32Table[ ((s8)CRC ^ (*buf++)) & 0xFF ] ^ (CRC >> 8);
        CRC = CRC32Table[ ((s8)CRC ^ (*buf++)) & 0xFF ] ^ (CRC >> 8);
        CRC = CRC32Table[ ((s8)CRC ^ (*buf++)) & 0xFF ] ^ (CRC >> 8);
        CRC = CRC32Table[ ((s8)CRC ^ (*buf++)) & 0xFF ] ^ (CRC >> 8);
        CRC = CRC32Table[ ((s8)CRC ^ (*buf++)) & 0xFF ] ^ (CRC >> 8);
        CRC = CRC32Table[ ((s8)CRC ^ (*buf++)) & 0xFF ] ^ (CRC >> 8);
        // Account for the bytes just processed.
        HowManyBytes -= 8;
    }
    
    // As long as any input bytes remain to be processed.
    while( HowManyBytes-- )
    {
        CRC = CRC32Table[ ((s8)CRC ^ (*buf++)) & 0xFF ] ^ (CRC >> 8);
    }
    
    // Complement the remainder according to the Ethernet
    // standard and return the result.
    return( CRC ^ 0xFFFFFFFFL );
}
                       
/*------------------------------------------------------------
| CRCByte
|-------------------------------------------------------------
|
| PURPOSE: To compute the cyclic-redundancy check value for
| a byte combined with a given CRC value.
|
| DESCRIPTION: 
|
| EXAMPLE:     
|
| NOTES:   
|
| ASSUMES:  
|
| HISTORY: 03.01.94 copied from p. 241 of 'Mastering Serial
|                   Communications'
------------------------------------------------------------*/
u16
CRCByte( u16 CRC, u16 AByte )
{
    s16 count;
    u16 c;
    
    c = (u16) ( AByte & 255 );
    
    for( count = 8; --count >= 0; )
    {
        if(CRC & 0x8000)
        {
            CRC <<= 1;
            CRC += (((c <<= 1) & 0400) != 0);
            CRC ^= 0x1021;
        }
        else
        {
            CRC <<= 1;
            CRC += (((c <<= 1) & 0400) != 0);
        }
    }
    
    return(CRC);
}

/*------------------------------------------------------------
| CRCBytes
|-------------------------------------------------------------
|
| PURPOSE: To compute the cyclic-redundancy check value for
| a range of bytes combined with a given initial CRC value.
|
| DESCRIPTION: Use an initial value of 0 if no bytes have
| be accumulated.
|
| EXAMPLE:     
|
| NOTES:   
|
| ASSUMES:  
|
| HISTORY: 03.01.94 
|          01.16.95 fixed buffer advance. Trent found bug.
------------------------------------------------------------*/
u16
CRCBytes( u8* ABuffer, u32 ACount, u16 CRC )
{
    while( ACount-- )
    {
        CRC = CRCByte( CRC, *ABuffer++ );
    }
    
    return(CRC);
}

/*------------------------------------------------------------
| DeleteByteArray
|-------------------------------------------------------------
|
| PURPOSE: To delete byte array record and any associated 
|          byte data area.
|
| DESCRIPTION:  
|
| EXAMPLE:    DeleteByteArray( A );
|
| NOTE: 
|
| ASSUMES:  
|           
| HISTORY: 02.14.97 from 'MakeByteArray'.
------------------------------------------------------------*/
void
DeleteByteArray( ByteArray* A ) 
{
    // If there is data, free it.
    if( A->Data )
    {
        free( A->Data );
    }
    
    // Free the array record itself.
    free( A );
}

/*------------------------------------------------------------
| GetByte
|-------------------------------------------------------------
|
| PURPOSE: To fetch a byte.
|
| DESCRIPTION:  
|
| EXAMPLE:  b = GetByte( a );
|
| ASSUMES: 
|
| HISTORY: 01.22.97 
------------------------------------------------------------*/
u32
GetByte( u8* a )
{
    return( *a );
}

/*------------------------------------------------------------
| MakeByteArray
|-------------------------------------------------------------
|
| PURPOSE: To make a new byte array record and allocate the
|          byte data area.
|
| DESCRIPTION:  
|
| EXAMPLE:    A = MakeByteArray( Rows, Cols );
|
| NOTE: Doesn't initialize the cell data.
|
|       See 'MakeArray' for multi-dimensional bit arrays.
|
| ASSUMES: Packing order is same as CPU.
|          Rows begin on byte boundaries.
|          Access unit is a byte.
|           
| HISTORY: 02.14.97 from 'MakeBitArray'.
------------------------------------------------------------*/
ByteArray*
MakeByteArray( u32 RowCount, u32 ColCount )
{
    ByteArray*  A;
    
    // Allocate a byte array specification record.
    A = (ByteArray*) malloc( sizeof( ByteArray ) );
    
    // Save the dimension extents.
    A->RowCount = RowCount;
    A->ColCount = ColCount;
    
    // Allocate the storage for the bit data.
    A->Data = (u8*) malloc( ColCount * RowCount );
    
    // Return the result.
    return( A );
}

/*------------------------------------------------------------
| OrBytes
|-------------------------------------------------------------
|
| PURPOSE: To OR a range of bytes to another.
|
| DESCRIPTION: Correctly handles overlapping series of bytes. 
|
| EXAMPLE:  OrBytes( From, To, (u32) 5 );
|
| NOTE: This could be sped up by moving 32-bit chunks where
|       possible.
|
| ASSUMES: 
|
| HISTORY: 01.22.97
------------------------------------------------------------*/
void
OrBytes( u8* From, u8* To, u32 Count )
{
    if( From >= To )
    {
        while( Count-- )
        {
            *To++ |= *From++;
        }
    }
    else
    {
        To   += Count;
        From += Count;
        
        while( Count-- )
        {
            *--To |= *--From;
        }
    }
}

/*------------------------------------------------------------
| OrBytesTwoSrc
|-------------------------------------------------------------
|
| PURPOSE: To OR two ranges of bytes to produce a third.
|
| DESCRIPTION:  
|
| EXAMPLE: 
|
|
| NOTE: 
|
| ASSUMES: 
|
| HISTORY:  12.27.95 
------------------------------------------------------------*/
void
OrBytesTwoSrc( u8* SrcA, u8* SrcB, u8* Dst, u32 Count )
{
    while( Count-- )
    {
        *Dst++ = (u8) ( *SrcA++ | *SrcB++ );
    }
}

/*------------------------------------------------------------
| PutByte
|-------------------------------------------------------------
|
| PURPOSE: To store a byte.
|
| DESCRIPTION:  
|
| EXAMPLE:    PutByte( a, b );
|
| ASSUMES: 
|
| HISTORY: 01.22.97 
------------------------------------------------------------*/
void
PutByte( u8* a, u32 b )
{
    *a = (u8) b;
}

/*------------------------------------------------------------
| Uint16ToBytes
|-------------------------------------------------------------
|
| PURPOSE: To convert a u16 to two bytes ordered LSB:MSB.
|
| DESCRIPTION: Different CPUs organize memory in different 
| ways.  This procedure is used to allow communication of
| u16-size data from one computer to another.
|
| EXAMPLE:  Uint16ToBytes(Au16,ABuffer);
|
| NOTE: 
|
| ASSUMES: 
|
| HISTORY:  03.12.94 
------------------------------------------------------------*/
void
Uint16ToBytes(u16 Au16, u8* AtBytes)
{
    AtBytes[0] = (u8) Au16;
    
    AtBytes[1] = (u8) (Au16>>8);
}
    
/*------------------------------------------------------------
| Uint32ToBytes
|-------------------------------------------------------------
|
| PURPOSE: To convert a u32 to four bytes ordered LSB->MSB.
|
| DESCRIPTION: Different CPUs organize memory in different 
| ways.  This procedure is used to allow communication of
| u32-size data from one computer to another.
|
| EXAMPLE:  Uint32ToBytes(Au32,ABuffer);
|
| NOTE: 
|
| ASSUMES: 
|
| HISTORY:  03.12.94 
------------------------------------------------------------*/
void
Uint32ToBytes( u32  Au32, u8* AtBytes )
{
    AtBytes[0] = (u8) Au32;
    AtBytes[1] = (u8) (Au32>>8);
    AtBytes[2] = (u8) (Au32>>16);
    AtBytes[3] = (u8) (Au32>>24);
}
   
/*------------------------------------------------------------
| ValidateBytesMatch
|-------------------------------------------------------------
|
| PURPOSE: To confirm that two strings that are expected to
|          match in fact do match.
|
| DESCRIPTION: Halts in the debugger if the two ranges of
| bytes differ.
|
| EXAMPLE: 
|
| NOTE: 
|
| ASSUMES: The two strings are supposed to match.
|
| HISTORY: 01.18.99 From 'zlib' 'chech_match' routine.
------------------------------------------------------------*/
void
ValidateBytesMatch( u8* A, u8* B, u32 ByteCount )
{
    // If the two strings differ.
    if( IsMatchingBytes( A, B, ByteCount ) == 0 )
    {
        // Halt in the debugger.
//TBD       Debugger();
    }
}

/*------------------------------------------------------------
| XorBytes
|-------------------------------------------------------------
|
| PURPOSE: To XOR a range of bytes to another.
|
| DESCRIPTION: Correctly handles overlapping series of bytes. 
|
| EXAMPLE:  XorBytes( From, To, (u32) 5 );
|
| NOTE: This could be sped up by moving 32-bit chunks where
|       possible.
|
| ASSUMES: 
|
| HISTORY: 01.22.97
------------------------------------------------------------*/
void
XorBytes( u8* From, u8* To, u32 Count )
{
    if( From >= To )
    {
        while( Count-- )
        {
            *To++ ^= *From++;
        }
    }
    else
    {
        To   += Count;
        From += Count;
        
        while( Count-- )
        {
            *--To ^= *--From;
        }
    }
}
