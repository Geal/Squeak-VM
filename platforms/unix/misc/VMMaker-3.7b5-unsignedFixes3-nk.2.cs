'From Squeak3.7 of ''4 September 2004'' [latest update: #5989] on 18 March 2005 at 11:59:15 am'!!CArray methodsFor: 'converting' stamp: 'nk 3/16/2005 16:49'!coerceTo: cTypeString sim: interpreterSimulator	cTypeString = 'int' ifTrue: [^ self ptrAddress].	cTypeString = 'unsigned' ifTrue: [^ self ptrAddress].	^ self! !!ObjectMemory methodsFor: 'allocation' stamp: 'nk 3/16/2005 16:59'!allocate: byteSize headerSize: hdrSize h1: baseHeader h2: classOop h3: extendedSize doFill: doFill with: fillWord 	"Allocate a new object of the given size and number of header words. (Note: byteSize already includes space for the base header word.) Initialize the header fields of the new object and fill the remainder of the object with the given value.	May cause a GC"	| newObj remappedClassOop end i |	self inline: true.	self var: #i type: 'unsigned'.	self var: #end type: 'unsigned'.	"remap classOop in case GC happens during allocation"	hdrSize > 1 ifTrue: [self pushRemappableOop: classOop].	newObj _ self allocateChunk: byteSize + (hdrSize - 1 * 4).	hdrSize > 1 ifTrue: [remappedClassOop _ self popRemappableOop].	hdrSize = 3		ifTrue: [self longAt: newObj put: (extendedSize bitOr: HeaderTypeSizeAndClass).			self longAt: newObj + 4 put: (remappedClassOop bitOr: HeaderTypeSizeAndClass).			self longAt: newObj + 8 put: (baseHeader bitOr: HeaderTypeSizeAndClass).			newObj _ newObj + 8].	hdrSize = 2		ifTrue: [self longAt: newObj put: (remappedClassOop bitOr: HeaderTypeClass).			self longAt: newObj + 4 put: (baseHeader bitOr: HeaderTypeClass).			newObj _ newObj + 4].	hdrSize = 1		ifTrue: [self longAt: newObj put: (baseHeader bitOr: HeaderTypeShort)].	"clear new object"	doFill ifTrue: [end _ newObj + byteSize.			i _ newObj + 4.			[i < end] whileTrue: [self longAt: i put: fillWord.					i _ i + 4]].	DoAssertionChecks		ifTrue: [self okayOop: newObj.			self oopHasOkayClass: newObj.			(self objectAfter: newObj) = freeBlock				ifFalse: [self error: 'allocate bug: did not set header of new oop correctly'].			(self objectAfter: freeBlock) = endOfMemory				ifFalse: [self error: 'allocate bug: did not set header of freeBlock correctly']].	^newObj! !!ObjectMemory methodsFor: 'object enumeration' stamp: 'nk 3/16/2005 16:25'!startOfMemory	"Return the start of object memory."	^ self cCode: '(unsigned) memory'! !!Interpreter methodsFor: 'image save/restore' stamp: 'nk 3/16/2005 16:59'!readImageFromFile: f HeapSize: desiredHeapSize StartingAt: imageOffset	"Read an image from the given file stream, allocating the given amount of memory to its object heap. Fail if the image has an unknown format or requires more than the given amount of memory."	"Details: This method detects when the image was stored on a machine with the opposite byte ordering from this machine and swaps the bytes automatically. Furthermore, it allows the header information to start 512 bytes into the file, since some file transfer programs for the Macintosh apparently prepend a Mac-specific header of this size. Note that this same 512 bytes of prefix area could also be used to store an exec command on Unix systems, allowing one to launch Smalltalk by invoking the image name as a command."	"This code is based on C code by Ian Piumarta and Smalltalk code by Tim Rowledge. Many thanks to both of you!!!!"	| swapBytes headerStart headerSize dataSize oldBaseAddr minimumMemory memStart bytesRead bytesToShift heapSize |	self var: #f declareC: 'sqImageFile f'.	self var: #headerStart declareC: 'squeakFileOffsetType headerStart'.	self var: #dataSize declareC: 'size_t dataSize'.	self var: #imageOffset declareC: 'squeakFileOffsetType imageOffset'.	self var: #memStart type: 'unsigned'.	swapBytes _ self checkImageVersionFrom: f startingAt: imageOffset.	headerStart _ (self sqImageFilePosition: f) - 4.  "record header start position"	headerSize			_ self getLongFromFile: f swap: swapBytes.	dataSize				_ self getLongFromFile: f swap: swapBytes.	oldBaseAddr			_ self getLongFromFile: f swap: swapBytes.	specialObjectsOop	_ self getLongFromFile: f swap: swapBytes.	lastHash			_ self getLongFromFile: f swap: swapBytes.	savedWindowSize	_ self getLongFromFile: f swap: swapBytes.	fullScreenFlag		_ self getLongFromFile: f swap: swapBytes.	extraVMMemory		_ self getLongFromFile: f swap: swapBytes.	lastHash = 0 ifTrue: [		"lastHash wasn't stored (e.g. by the cloner); use 999 as the seed"		lastHash _ 999].	"decrease Squeak object heap to leave extra memory for the VM"	heapSize _ self cCode: 'reserveExtraCHeapBytes(desiredHeapSize, extraVMMemory)'.	"compare memory requirements with availability".	minimumMemory _ dataSize + 100000.  "need at least 100K of breathing room"	heapSize < minimumMemory ifTrue: [		self insufficientMemorySpecifiedError].	"allocate a contiguous block of memory for the Squeak heap"	memory _ self cCode: '(unsigned char *) sqAllocateMemory(minimumMemory, heapSize)'.	memory = nil ifTrue: [self insufficientMemoryAvailableError].	memStart _ self startOfMemory.	memoryLimit _ (memStart + heapSize) - 24.  "decrease memoryLimit a tad for safety"	endOfMemory _ memStart + dataSize.	"position file after the header"	self sqImageFile: f Seek: headerStart + headerSize.	"read in the image in bulk, then swap the bytes if necessary"	bytesRead _ self cCode: 'sqImageFileRead(memory, sizeof(unsigned char), dataSize, f)'.	bytesRead ~= dataSize ifTrue: [self unableToReadImageError].	headerTypeBytes at: 0 put: 8. "3-word header (type 0)"		headerTypeBytes at: 1 put: 4. "2-word header (type 1)"	headerTypeBytes at: 2 put: 0. "free chunk (type 2)"		headerTypeBytes at: 3 put: 0. "1-word header (type 3)"	swapBytes ifTrue: [self reverseBytesInImage].	"compute difference between old and new memory base addresses"	bytesToShift _ memStart - oldBaseAddr.	self initializeInterpreter: bytesToShift.  "adjusts all oops to new location"	^ dataSize! !!Interpreter methodsFor: 'utilities' stamp: 'nk 3/16/2005 16:30'!externalizeIPandSP	"Copy the local instruction and stack pointer to global variables for use in primitives and other functions outside the interpret loop."	instructionPointer _ self cCoerce: localIP to: 'unsigned'.	stackPointer _ self cCoerce: localSP to: 'unsigned'.	theHomeContext _ localHomeContext.! !!Interpreter methodsFor: 'image segment in/out' stamp: 'nk 3/16/2005 17:00'!oopHasAcceptableClass: signedOop	"Similar to oopHasOkayClass:, except that it only returns true or false."	| oopClass formatMask behaviorFormatBits oopFormatBits oop |	(self isIntegerObject: signedOop) ifTrue: [^ true].	self var: #oop type: 'unsigned'.	self var: #oopClass type: 'unsigned'.	oop := self cCoerce: signedOop to: 'unsigned'.	oop < endOfMemory ifFalse: [^ false].	((oop \\ 4) = 0) ifFalse: [^ false].	(oop + (self sizeBitsOf: oop)) < endOfMemory ifFalse: [^ false].	oopClass := self cCoerce: (self fetchClassOf: oop) to: 'unsigned'.	(self isIntegerObject: oopClass) ifTrue: [^ false].	(oopClass < endOfMemory) ifFalse: [^ false].	((oopClass \\ 4) = 0) ifFalse: [^ false].	(oopClass + (self sizeBitsOf: oopClass)) < endOfMemory ifFalse: [^ false].	((self isPointers: oopClass) and: [(self lengthOf: oopClass) >= 3]) ifFalse: [^ false].	(self isBytes: oop)		ifTrue: [ formatMask _ 16rC00 ]  "ignore extra bytes size bits"		ifFalse: [ formatMask _ 16rF00 ].	behaviorFormatBits _ (self formatOfClass: oopClass) bitAnd: formatMask.	oopFormatBits _ (self baseHeader: oop) bitAnd: formatMask.	behaviorFormatBits = oopFormatBits ifFalse: [^ false].	^ true! !!Interpreter methodsFor: 'debug support' stamp: 'nk 3/16/2005 16:59'!okayOop: signedOop	"Verify that the given oop is legitimate. Check address, header, and size but not class."	| sz type fmt oop |	self var: #oop type: 'unsigned'.	oop := self cCoerce: signedOop to: 'unsigned'.	"address and size checks"	(self isIntegerObject: oop) ifTrue: [ ^true ].	(oop < endOfMemory)		ifFalse: [ self error: 'oop is not a valid address' ].	((oop \\ 4) = 0)		ifFalse: [ self error: 'oop is not a word-aligned address' ].	sz _ self sizeBitsOf: oop.	(oop + sz) < endOfMemory		ifFalse: [ self error: 'oop size would make it extend beyond the end of memory' ].	"header type checks"	type _ self headerType: oop.	type = HeaderTypeFree		ifTrue:  [ self error: 'oop is a free chunk, not an object' ].	type = HeaderTypeShort ifTrue: [		(((self baseHeader: oop) >> 12) bitAnd: 16r1F) = 0			ifTrue:  [ self error: 'cannot have zero compact class field in a short header' ].	].	type = HeaderTypeClass ifTrue: [		((oop >= 4) and: [(self headerType: oop - 4) = type])			ifFalse: [ self error: 'class header word has wrong type' ].	].	type = HeaderTypeSizeAndClass ifTrue: [		((oop >= 8) and:		 [(self headerType: oop - 8) = type and:		 [(self headerType: oop - 4) = type]])			ifFalse: [ self error: 'class header word has wrong type' ].	].	"format check"	fmt _ self formatOf: oop.	((fmt = 5) | (fmt = 7))		ifTrue:  [ self error: 'oop has an unknown format type' ].	"mark and root bit checks"	((self longAt: oop) bitAnd: 16r20000000) = 0		ifFalse: [ self error: 'unused header bit 30 is set; should be zero' ]."xxx	((self longAt: oop) bitAnd: MarkBit) = 0		ifFalse: [ self error: 'mark bit should not be set except during GC' ].xxx"	(((self longAt: oop) bitAnd: RootBit) = 1 and:	 [oop >= youngStart])		ifTrue: [ self error: 'root bit is set in a young object' ].	^true! !!Interpreter methodsFor: 'debug support' stamp: 'nk 3/16/2005 16:59'!oopHasOkayClass: signedOop	"Attempt to verify that the given oop has a reasonable behavior. The class must be a valid, non-integer oop and must not be nilObj. It must be a pointers object with three or more fields. Finally, the instance specification field of the behavior must match that of the instance."	| oop oopClass formatMask behaviorFormatBits oopFormatBits |	self var: #oop type: 'unsigned'.	self var: #oopClass type: 'unsigned'.	oop := self cCoerce: signedOop to: 'unsigned'.	self okayOop: oop.	oopClass := self cCoerce: (self fetchClassOf: oop) to: 'unsigned'.	(self isIntegerObject: oopClass)		ifTrue: [ self error: 'a SmallInteger is not a valid class or behavior' ].	self okayOop: oopClass.	((self isPointers: oopClass) and: [(self lengthOf: oopClass) >= 3])		ifFalse: [ self error: 'a class (behavior) must be a pointers object of size >= 3' ].	(self isBytes: oop)		ifTrue: [ formatMask _ 16rC00 ]  "ignore extra bytes size bits"		ifFalse: [ formatMask _ 16rF00 ].	behaviorFormatBits _ (self formatOfClass: oopClass) bitAnd: formatMask.	oopFormatBits _ (self baseHeader: oop) bitAnd: formatMask.	behaviorFormatBits = oopFormatBits		ifFalse: [ self error: 'object and its class (behavior) formats differ' ].	^true! !!ObjectMemory class methodsFor: 'translation' stamp: 'nk 3/16/2005 17:24'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: #memory type: #'unsigned char*'.	aCCodeGenerator		var: #remapBuffer		declareC: 'int remapBuffer[', (RemapBufferSize + 1) printString, ']'.	aCCodeGenerator		var: #rootTable		declareC: 'int rootTable[', (RootTableSize + 1) printString, ']'.	aCCodeGenerator		var: #headerTypeBytes		declareC: 'int headerTypeBytes[4]'.		aCCodeGenerator var: #youngStart type: 'unsigned'.	aCCodeGenerator var: #endOfMemory type: 'unsigned'.	aCCodeGenerator var: #memoryLimit type: 'unsigned'.	aCCodeGenerator var: #youngStartLocal type: 'unsigned'.! !!VMMakerTool methodsFor: 'drag and drop' stamp: 'nk 3/10/2005 17:06'!acceptDroppingMorph: transferMorph event: evt inMorph: aMorph	"Here we are fetching information from the dropped transferMorph and performing the correct action for this drop.	As long as the source is part of this tool, move the dragged item from the source list to the destination list"	(transferMorph isKindOf: HandleMorph) ifTrue: [ ^false ].	transferMorph source model = self ifFalse:[^false].	^self moveItem: transferMorph passenger from: transferMorph source to: aMorph! !VMMakerTool class removeSelector: #new!InterpreterProxy class removeSelector: #new!BalloonEngineSimulation class removeSelector: #new!