/*------------------------------------------------------------
| TLGeometry.c
|-------------------------------------------------------------
|
| PURPOSE: To provide geometry functions.
|
| DESCRIPTION: 
|
| All angles generated by the C library calls fall in the 
| range -pi <= a <= pi.
|        
| In polar coordinates the radius vector 'r' can be positive
| or negative.
|
| NOTE: 
|
| HISTORY: 04.02.96
------------------------------------------------------------*/
    
#include <string.h>
#include <stdio.h>

#include "TLTarget.h"

#include "TLTypes.h"
#include "TLAscii.h"
#include "TLStrings.h"
#include "TLVector.h"
#include "TLf64.h"
#include "TLMatrixAlloc.h"
#include "TLPoints.h"
#include "TLGeometry.h"

/*------------------------------------------------------------
| DistanceOfPointToGeneralLine
|-------------------------------------------------------------
|
| PURPOSE: To find the distance from an (x,y) point to a line
|          in general form.
|
| DESCRIPTION:  
|
| The distance 'D' of a point P1( x1,y1 ) from a general line
| Ax + By + C = 0 is:
|
|                      Ax1 + By1 + C
|           D = ---------------------------
|                  +/- sqrt( A^2 + B^2 )
|
| with the radical sign being the opposite of the constant 
| term C when C != 0 and the same as the sign of
| B when C = 0. 
|
| The distance, 'D', then is positive if P1 and the origin 
| lie on opposite sides of the line, otherwise 'D' is 
| negative.
|
| EXAMPLE:  
|
| NOTE: See 'CRC Standard Math Tables,  23rd ed', p. 369. 
|
| ASSUMES: 
|           
| HISTORY: 04.06.96 untested.
|          03.12.00 Tested OK for four different points and
|                   two different lines, one parallel to
|                   the X axis and the other a 45 degree
|                   line through the origin.
------------------------------------------------------------*/
f64
DistanceOfPointToGeneralLine( General2DLine* g, XY* p )
{
    f64 AB, D, A, B, C;
    
    A = g->A;
    B = g->B;
    C = g->C;
        
    // AB is always non-zero.
    AB = sqrt( A*A + B*B );
    
    // Make sign of 'AB' opposite to 'C' if 'C' is non-zero 
    // else make the sign the same as 'B'. 
    if( C > 0 || ( C == 0 && B < 0 ) ) 
    {
        AB = -AB;
    }

    D = (A * p->x + B * p->y + C) / AB;
    
    return( D );
}

/*------------------------------------------------------------
| DistanceOfPointsToHessianLine
|-------------------------------------------------------------
|
| PURPOSE: To find the distances of (x,y) points to a line
|          in Hessian normal form.
|
| DESCRIPTION: Returns the distances at the given buffer and 
| the item count as the return value. 
|
| Hessian normal form is:
|
|           x * cos( a ) + y * sin( a ) - r = 0
|
|                       where 'a' is the counter-clockwise
|                             angle from the x axis
|
|                       and 'r' is the distance from the
|                           origin to the nearest point on
|                           the line.
|  
| The distance 'D' of a point P1( x1,y1 ) from a Hessian
| line is:
|
|           D = x1 * cos( a ) + y1 * sin( a ) - r
| 
| such that 'D' is positive if P1 and the origin lie on 
| opposite sides of the line, otherwise 'D' is negative.
|
| EXAMPLE:  
|
| NOTE: 
|
| ASSUMES: Room in buffer for the result.
|          Vector is in Cartesian form.
|           
| HISTORY: 04.08.96 from 'DistanceOfPointToHessianLine'.
------------------------------------------------------------*/
f64
DistanceOfPointsToHessianLine( HessianLine* h, 
                               Vector*      V,
                               f64*         Items )
{
    f64     a,r,cosa,sina;
    s32     ItemCount,i;
    f64*    X;
    f64*    Y;
    
    a = h->a;
    r = h->r;
    
    sina = sin(a);
    cosa = cos(a);
    
    X = V->X;
    Y = V->Y;
    
    ItemCount = V->ItemCount;
    
    for(i = 0; i < ItemCount; i++)
    {
        *Items++ = X[i] * cosa +  Y[i] * sina - r;
    }
    
    return( ItemCount );
}

/*------------------------------------------------------------
| DistanceOfPointToHessianLine
|-------------------------------------------------------------
|
| PURPOSE: To find the distance from an (x,y) point to a line
|          in Hessian normal form.
|
| DESCRIPTION:  
|
| Hessian normal form is:
|
|           x * cos( a ) + y * sin( a ) - r = 0
|
|                       where 'a' is the counter-clockwise
|                             angle from the x axis
|
|                       and 'r' is the distance from the
|                           origin to the nearest point on
|                           the line.
|  
| The distance 'D' of a point P1( x1,y1 ) from a Hessian
| line is:
|
|           D = x1 * cos( a ) + y1 * sin( a ) - r
| 
| such that 'D' is positive if P1 and the origin lie on 
| opposite sides of the line, otherwise 'D' is negative.
|
| EXAMPLE:  
|
| NOTE: 
|
| ASSUMES: 
|           
| HISTORY: 04.02.96 
------------------------------------------------------------*/
f64
DistanceOfPointToHessianLine( HessianLine* h, XY* p )
{
    f64 a;
    
    a = h->a;
    
    return( p->x * cos( a ) + p->y * sin( a ) - h->r );
}

/*------------------------------------------------------------
| FindXonGeneralLineGivenY
|-------------------------------------------------------------
|
| PURPOSE: To find the X value given a line in general form
|          and the Y value.
|
| DESCRIPTION: 
|
| The general line equation is:
|
|      A * x + B * y + C = 0 
|
|                       where both 'A' and 'B' are never 0.
|
|                  solving for x:
|
|                           -(B * y + C)
|                      x = ---------------
|                                 A
| EXAMPLE:  
|
| ASSUMES: Not a horizontal line.
|           
| HISTORY: 04.04.96 
------------------------------------------------------------*/
f64 
FindXonGeneralLineGivenY( General2DLine* g, f64 y )
{
    // If 'A' is zero, then this is a horizontal line 
    // independent of the value of 'y'. 
    if( g->A == 0 ) Debugger();
    
    return( -( g->B * y + g->C ) / g->A );
}

/*------------------------------------------------------------
| FindYonGeneralLineGivenX
|-------------------------------------------------------------
|
| PURPOSE: To find the Y value given a line in general form
|          and the X value.
|
| DESCRIPTION: 
|
| The general line equation is:
|
|      A * x + B * y + C = 0 
|
|                       where both 'A' and 'B' are never 0.
|
|                  solving for y:
|
|                           -(A * x + C)
|                      y = ---------------
|                                 B
| EXAMPLE:  
|
| ASSUMES: Not a vertical line.
|           
| HISTORY: 04.04.96 
------------------------------------------------------------*/
f64 
FindYonGeneralLineGivenX( General2DLine* g, f64 x )
{
    // If 'B' is zero, then this is a vertical line 
    // independent of the value of 'x'. 
    if( g->B == 0 ) Debugger();
    
    return( -( g->A * x + g->C ) / g->B );
}

/*------------------------------------------------------------
| GeneralLineToHessianLine
|-------------------------------------------------------------
|
| PURPOSE: To convert a line from General form in Cartesian 
| coordinates to Hessian normal form.
|
| DESCRIPTION: "An equation Ax + By + C = 0 can be changed
| to normal form by dividing all cooeficients by 
| +/-sqrt( A^2 + B^2 ), the sign being the opposite of the 
| constant term C when C != 0 and the same as the sign of
| B when C = 0."
|
| But we don't use that method here because of unsolved
| problems involving the signs.
| 
|              
| EXAMPLE:  
|
| NOTE: See 'HessianLineToGeneralLine' for more on these line
| forms.  See also p. 369 of CRC 23rd edition.
|
| ASSUMES:
|           
| HISTORY: 04.04.96 
|          04.06.96 revised.
|          04.06.96 Tested OK. 
------------------------------------------------------------*/
void
GeneralLineToHessianLine( General2DLine* g, HessianLine* h )
{
    f64         An,A,B,C;
    PointSlope  s;
    
    A = g->A; 
    B = g->B;
    C = g->C;
    
    // If 'B' is zero then this is a vertical line.
    if( B == 0 )
    {
        h->r = -C/A; // The x intercept is the distance 
                   // from the origin to the line.

        // Normalize A to +/- 1.
        An = (A < 0) ? -1.0 : 1.0 ;
        
        h->a = acos( An ); // Either 1 or -1.
    }
    else // Not a vertical line so can use point-slope
         // conversion.
    {
        // Calculate the 'y' intercept.
        s.b = -C/B;
    
        // Calculate the slope.
        s.m = -A/B;
    
        PointSlopeToHessianLine( &s, h );
    }
}

/*------------------------------------------------------------
| GeneralLineToPointSlope
|-------------------------------------------------------------
|
| PURPOSE: To convert a line from General form in Cartesian 
| coordinates to point-slope form.
|
| DESCRIPTION:  
| 
| General form is:
|
|          A * x + B * y + C = 0
|
|                       where both 'A' and 'B' are never 0.
|
|                  solving for y:
|
|                           -(A * x + C)
|                      y = ---------------
|                                 B
|
|                      if x == 0 then, the y intercept is
|
|                           -C
|                      y = ----- 
|                            B
|                 
|                  formatting as point-slope:
|
|                           -(A * x + C)
|                      y = ---------------
|                                 B
|
|                           -A        C 
|                      y = ---- X - ----- 
|                            B        B
|              
| Point-slope form is:
|
|                y = m * x + b
|
|                       where 'm' is the slope,
|                             m = (y1 - y0)/(x1 - x0) 
|
|                       and 'b' is the 'y' intercept,
|                                b = y0 - (m * x0) 
| EXAMPLE:  
|
| NOTE: 
|
| ASSUMES: Not a vertical line.
|           
| HISTORY: 04.04.96
|          04.06.96 Tested OK. 
------------------------------------------------------------*/
void
GeneralLineToPointSlope( General2DLine* g, PointSlope* s )
{
    f64 A,B,C;
    
    A = g->A; 
    B = g->B;
    C = g->C;

    // If 'B' is zero, then this is a vertical line 
    // independent of the value of 'x'. 
    if( B == 0 ) Debugger();

    // Calculate the 'y' intercept.
    s->b = -C/B;
    
    // Calculate the slope.
    s->m = -A/B;
}

/*------------------------------------------------------------
| HessianLineToGeneralLine
|-------------------------------------------------------------
|
| PURPOSE: To convert a line expressed in Hessian normal form
| to General form in Cartesian coordinates.
|
| DESCRIPTION:  
|
| Hessian normal form is:
|
|
|          x * cos( a ) + y * sin( a ) - r = 0
|
| General form is:
|
|          A * x + B * y + C = 0
|
| SOLUTION: Break the problem into two parts: 
|
| 1. Check for and handle vertical lines.
| 2. Handle non-vertical lines by converting to point-slope 
|    and then to general form.
|
| EXAMPLE:  
|
| NOTE: See 'TLGeometry.h'.
|
| ASSUMES: Distance is always positive.
|           
| HISTORY: 04.03.96 
|          04.06.96 Simplified.
|          04.06.96 Tested OK. 
------------------------------------------------------------*/
void
HessianLineToGeneralLine( HessianLine* h, General2DLine* g )
{
    f64 a, r, cosa, sina, m, b;
    
    a = h->a;
    r = h->r;
    
    // Compute the first two parameters.
    sina = Chop( sin(a) );
    cosa = Chop( cos(a) );
    
    // Test for vertical line.
    if( sina == 0 )
    {
        g->A = cosa; // Either 1 or -1.
        g->B = 0;
        g->C = cosa * -r; // The x intercept is the distance 
                          // from the origin to the line.
    }
    else // If not a vertical line
    {
        if( cosa == 0 )
        {
            m = 0; // Horizontal line.
        }
        else // Find the slope of the line by taking
             // the negative reciprocal of the normal line
             // slope.
        {
            m = -1.0 / tan( a );
        }
        
        b = r / sina;
        
        g->A = m;
        g->B = -1.0;
        g->C = b;
    }   
}   

/*------------------------------------------------------------
| HessianLineToPointSlope
|-------------------------------------------------------------
|
| PURPOSE: To convert a line expressed in Hessian normal form
| to point-slope form.
|
| DESCRIPTION: The formula for point-slope form is:
|
|                y = m * x + b
|
|                       where 'm' is the slope,
|                             m = (y1 - y0)/(x1 - x0) 
|
|                       and 'b' is the 'y' intercept,
|                                b = y0 - (m * x0) 
|
| Hessian Normal form is:
|
|           x * cos( a ) + y * sin( a ) - d = 0
|
|                       where 'a' is the counter-clockwise
|                             angle from the x axis
|
|                       and 'd' is the distance from the
|                           origin to the nearest point on
|                           the line.
|
| solving for y,
|
|            -( cos(a) * x - d )
|       y = -------------------
|                  sin(a)
|
| with x == 0, this becomes:
|
|                   d
|        y = b = --------
|                 sin(a)
|
| The slope 'm' is related to the angle 'a' as:
|
|              m = - 1.0 / tan( a ) , for non-horizontal lines,
|              m = 0, for horizontal lines.
| EXAMPLE:  
|
| NOTE: Hessian normal form can be used to specify any line
|       whereas vertical lines are undefined for the point-slope
|       form.
|
| ASSUMES: Line isn't vertical.
|           
| HISTORY: 04.02.96 
|          04.06.96 Tested OK. 
------------------------------------------------------------*/
void
HessianLineToPointSlope( HessianLine* h, PointSlope* s )
{
    f64 a;
    
    a = h->a;
    
    if( cos(a) == 0 )
    {
        s->m = 0;
    }
    else
    {
        s->m = -1.0 / tan( a );
    }
        
    s->b = h->r / sin( a );
}   

/*------------------------------------------------------------
| IntersectLineAndRectangle
|-------------------------------------------------------------
|
| PURPOSE: To find the (x,y) points that mark the intersection
|          of a line and a rectangle.
|
| DESCRIPTION: Returns count of intersection points and
| the points of intersection, if any.
|
| Returns 0 if lines don't intersect.
|
| Line is given in General form:
|
|      A * x + B * y + C = 0  
|
| EXAMPLE:  
|
| NOTE: 
|
| ASSUMES: 
|           
| HISTORY: 04.06.96 
------------------------------------------------------------*/
s32 
IntersectLineAndRectangle( General2DLine* g, 
                           Rectangle2*  r, 
                           TwoPoints*   p ) 
{
    f64         xmin, xmax, ymin, ymax; 
    TwoPoints   seg;
    XY*         pt;
    s32         i;
    
    // Unpack the parameters.
    xmin = r->min.x;
    xmax = r->max.x;
    ymin = r->min.y;
    ymax = r->max.y;
    
    // Keep track of how many points found.
    i = 0;
    
    // Refer to the first of the two return points.
    pt = (XY*) p;
    
    // Refer to the left edge of the rectangle.
    seg.a.x = xmin;
    seg.a.y = ymin;
    seg.b.x = xmin;
    seg.b.y = ymax;
    
    // Find the intersection of the line and the left edge.                           
    if( IntersectLineAndSegment( g, &seg, &pt[i] ) )
    {
        i++; // Count one point found.
    }
    
    // Refer to the right edge of the rectangle.
    seg.a.x = xmax;
    seg.a.y = ymin;
    seg.b.x = xmax;
    seg.b.y = ymax;
                                
    // Find the intersection of the line and the right edge.                           
    if( IntersectLineAndSegment( g, &seg, &pt[i] ) )
    {
        i++; // Count the found point.
        if( i == 2 )
        {
            return( i );
        }
    }
        
    // Refer to the top edge of the rectangle.
    seg.a.x = xmin;
    seg.a.y = ymax;
    seg.b.x = xmax;
    seg.b.y = ymax;
                                
     // Find the intersection of the line and the top edge.                           
    if( IntersectLineAndSegment( g, &seg, &pt[i] ) )
    {
        i++; // Count the found point.
        if( i == 2 )
        {
            return( i );
        }
    }
 
    // Refer to the bottom edge of the rectangle.
    seg.a.x = xmin;
    seg.a.y = ymin;
    seg.b.x = xmax;
    seg.b.y = ymin;
                                
     // Find the intersection of the line and the bottom edge.                           
    if( IntersectLineAndSegment( g, &seg, &pt[i] ) )
    {
        i++; // Count the found point.
    }
    
    // Return the number of points.
    return( i );
}

/*------------------------------------------------------------
| IntersectLineAndSegment
|-------------------------------------------------------------
|
| PURPOSE: To find the (x,y) point that mark the intersection
|          of a general line and a line segment.
|
| DESCRIPTION: Returns '1' if there is an intersection 
| between the line segment and the general line, and also
| returns the point.
|
| If there is no intersection '0' is returned and the 
| return point is undefined.
|
| Line is given in General form:
|
|      A * x + B * y + C = 0 
|
| Segment is given in two-point form with the segment falling
| between the points, inclusive. 
|
| EXAMPLE:  
|
| NOTE: 
|
| ASSUMES: 
|           
| HISTORY: 04.07.96 
------------------------------------------------------------*/
u32     
IntersectLineAndSegment( General2DLine* g, TwoPoints* t, XY* p ) 
{
    f64         xmin, xmax, ymin, ymax;
    f64         x, y;
    General2DLine edge;
    
    // Convert the line segment to a general form line.
    TwoPointLineToGeneralLine( t, &edge);
                               
    // Find the intersection of the two lines.                           
    if( IntersectTwoLines( g, &edge, p ) )
    {
        // Identify the extremes of the line segment.
        xmin = min( t->a.x, t->b.x );
        xmax = max( t->a.x, t->b.x );
        ymin = min( t->a.y, t->b.y );
        ymax = max( t->a.y, t->b.y );
        
        // Unpack the point.
        x = p->x;
        y = p->y;

        // Check to see if the point falls within the
        // extremes, adjusted by the ChopTolerance.
        if( xmin - ChopTolerance <= x && 
            x <= xmax + ChopTolerance &&
            ymin - ChopTolerance <= y && 
            y <= ymax + ChopTolerance )
        {
            return( 1 );
        }
        
        // Check to see if the point 
    }
    
    return( 0 );
}

/*------------------------------------------------------------
| IntersectTwoLines
|-------------------------------------------------------------
|
| PURPOSE: To find the (x,y) point that marks the intersection
|          of two lines.
|
| DESCRIPTION: Returns '1' if the lines intersect and the
| point of intersection.
|
| Lines are given in General form:
|
|      a1 * x + b1 * y + c1 = 0 and a2 * x + b2 * y + c2 = 0
|
| The formula for the intersection point is:
|
|            b1c2 - c1b2              c1a2 - a1c2
|      x0 = -------------  and y0 = ----------------
|            a1b2 - b1a2              a1b2 - b1a2
|
| If  a1b2 - b1a2 == 0, the lines are parallel.
|
| EXAMPLE:  
|
| NOTE: From 'Handbook of Mathematics' by Bronshtein and 
|          Semendyayev, p. 199.
|
| ASSUMES: 
|           
| HISTORY: 04.03.96 
|          04.07.96 revised.
------------------------------------------------------------*/
u32  
IntersectTwoLines( General2DLine* g1, General2DLine* g2, XY* p ) 
{
    f64 denom;
    f64 a1,b1,c1, a2,b2,c2;
    
    // Unpack the line parameters.
    a1 = g1->A;
    b1 = g1->B;
    c1 = g1->C;
    
    a2 = g2->A;
    b2 = g2->B;
    c2 = g2->C;
    
    // Could diagonal lines cause this to be zero too?
    denom = (a1 * b2) - (b1 * a2);
    
    // Check for parallel lines.
    if( denom == 0 )
    {
        return( 0 );
    }
    
    p->x = ( (b1 * c2) - (c1 * b2) ) / denom;
    p->y = ( (c1 * a2) - (a1 * c2) ) / denom;
    
    return( 1 );
}

/*------------------------------------------------------------
| MeanSqDistanceOfPointsToGeneralLine
|-------------------------------------------------------------
|
| PURPOSE: To find the average squared distance from a group 
|          of (x,y) points to a line in general form.
|
| DESCRIPTION:  
|
| The distance 'D' of a point P1( x1,y1 ) from a general line
| Ax + By + C = 0 is:
|
|                      Ax1 + By1 + C
|           D = ---------------------------
|                  +/- sqrt( A^2 + B^2 )
|
| with the radical sign being the opposite of the constant 
| term C when C != 0 and the same as the sign of
| B when C = 0. 
|
| The distance, 'D', then is positive if P1 and the origin 
| lie on opposite sides of the line, otherwise 'D' is 
| negative.
|
| Since we are concerned with the squared distance which is
| always positive we neglect the sign assignment.
|
| EXAMPLE:  
|
| NOTE: See 'CRC Standard Math Tables,  23rd ed', p. 369. 
|
| ASSUMES: 
|           
| HISTORY: 03.12.00 From DistanceOfPointToGeneralLine
------------------------------------------------------------*/
f64                   // OUT: Returns the mean squared distance.
MeanSqDistanceOfPointsToGeneralLine( 
    General2DLine* g, // The equation of the line.
                      //
    f64*           x, // The X values, the abscissa array.
                      // 
    f64*           y, // The Y values, the ordinate array.
                      //
    u32            n )// The number of points.
{
    f64 AB, D, A, B, C;
    f64 SumSq, ItemCount, MeanSq;
    
    // Get local copies of the general line parameters for
    // speed.
    A = g->A;
    B = g->B;
    C = g->C;
        
    // AB is always non-zero.
    AB = sqrt( A*A + B*B );
    
    // Clear the accumulator.
    SumSq = 0.0;
    
    // Remember the item count.
    ItemCount = (f64) n;
    
    // For all of the input points.
    while( n-- )
    {
        // Calculate the directed distance from the point 
        // to the line.
        D = (A * (*x++) + B * (*y++) + C) / AB;
        
        // Accumulate the squared distance.
        SumSq += D * D;
    }
    
    // Convert the total squared distance to mean.
    MeanSq = SumSq / ItemCount;
    
    // Return the mean squared distance.
    return( MeanSq );
}

/*------------------------------------------------------------
| PointSlopeToGeneralLine
|-------------------------------------------------------------
|
| PURPOSE: To convert a line expressed in point-slope form
| to general form.
|
| DESCRIPTION: The formula for point-slope form is:
|
|                y = m * x + b
|
|                       where 'm' is the slope,
|                             m = (y1 - y0)/(x1 - x0) 
|
|                       and 'b' is the 'y' intercept,
|                                b = y0 - (m * x0) 
|
| Point slope form can can be put into general
| form by rearranging the terms,
|
|       y = mx + b,
|
|       mx - y + b = 0
|
|       Ax + By + C = 0
|
|       where B == -1, A == m and C == b.
|
| EXAMPLE:  
|
| NOTE: 
|
| ASSUMES: 
|           
| HISTORY: 04.04.96 
|          04.06.96 Tested OK. 
------------------------------------------------------------*/
void
PointSlopeToGeneralLine( PointSlope* s, General2DLine* g )
{
    g->A = s->m;
    g->B = -1.0;
    g->C = s->b;
}

/*------------------------------------------------------------
| PointSlopeToHessianLine
|-------------------------------------------------------------
|
| PURPOSE: To convert a line expressed in point-slope form
| to Hessian normal form.
|
| DESCRIPTION: The formula for point-slope form is:
|
|                y = m * x + b
|
|                       where 'm' is the slope,
|                             m = (y1 - y0)/(x1 - x0) 
|
|                       and 'b' is the 'y' intercept,
|                                b = y0 - (m * x0) 
|
| Hessian normal form is:
|
|           x * cos( a ) + y * sin( a ) - r = 0
|
|                       where 'a' is the counter-clockwise
|                             angle from the x axis
|
|                       and 'r' is the distance from the
|                           origin to the nearest point on
|                           the line.
|
| The slope 'm' is related to the angle 'a' as:
|
|              a = arctan( - 1/m ), for non-horizontal lines,
|
|              a = pi/2, for horizontal line with
|                        b >= 0 or 
|              a = 3/2 pi, for horizontal lines with b < 0
|
| The distance from the origin to the line is calculated as:
|
|              d = sin(a) * b
|
| EXAMPLE:  
|
| NOTE: 
|
| ASSUMES: 
|           
| HISTORY: 04.02.96 
|          04.06.96 Tested OK. 
------------------------------------------------------------*/
void
PointSlopeToHessianLine( PointSlope* s, HessianLine* h )
{
    f64 n;
    
    if( s->m == 0 )
    {
        if( s->b >= 0 )
        {
            h->a = piby2;
        }
        else
        {
            h->a = -piby2;
        }
    }
    else // Not a horizontal line.
    {
        // Convert the slope of the normal to an angle.
        // The normal slope is the negative reciprocal.
        //
        n = -1.0 / s->m;
        
        // Calculate the arctan of the slope to get the
        // angle of the normal line.
        h->a = atan( n );
    }
    
    // Calculate the radius vector.
    h->r = sin( h->a ) * s->b;
    
    // 'r' may be negative here.
}

/*------------------------------------------------------------
| ReflectVectorAboutLine
|-------------------------------------------------------------
|
| PURPOSE: To reflect a vector of (x,y) points about a line
|          expressed in Hessian normal form.
|
| DESCRIPTION: 
|
| Hessian normal form is:
|
|           x * cos( a ) + y * sin( a ) - d = 0
|
|                       where 'a' is the counter-clockwise
|                             angle from the x axis
|
|                       and 'd' is the distance from the
|                           origin to the nearest point on
|                           the line.
|
| The distance 'D' of a point P1( x1,y1 ) from a Hessian
| line is:
|
|           D = x1 * cos( a ) + y1 * sin( a ) - d
|
|                     L\
|                       \      P1_
|                   .   /\  D / |
|                       \/\  /  |                dy
|                       /  \/   | dy,  sin(a) = -----
|                      / D /\   |                2D
|                   d /   /a \  |
|                    /   P2_____|_               dx
|                   /    |  dx  |      cos(a) = -----
|                  /            |                2D
|                 / a           |
|              --O--------------------------
|
| 
| such that 'D' is positive if P1 and the origin lie on 
| opposite sides of the line, otherwise 'D' is negative.
|
|
| The reflected point, P2, is found by:
|
|       x2 = x1 - dx
|       y2 = y1 - dy
|
|       dx = cos(a) * 2D
|       dy = sin(a) * 2D
|
| EXAMPLE:  
|
| NOTE: 
|
| ASSUMES: 
|           
| HISTORY: 04.02.96 Tested OK.
------------------------------------------------------------*/
void
ReflectVectorAboutLine( HessianLine* h, 
                        Vector* From, Vector* To )
{
    f64 a,r,cosa, sina,x1,y1,dx,dy,x2,y2,D;
    s32  i, ItemCount;
    
    a = h->a;
    r = h->r;
    
    // Compute the sines and cosines of the angle.
    cosa  = cos(a);
    sina  = sin(a);
    
    // Get the number of (x,y) pairs.
    ItemCount = From->ItemCount;
    
    // For each pair.
    for( i = 0; i < ItemCount; i++ )
    {
        // Get the (x,y) values for the first point.
        x1 = From->X[i];
        y1 = From->Y[i];
        
        // Compute the distance from the point to the
        // line.
        D = x1 * cosa + y1 * sina - r;
        
        // Compute the displacement from the first point
        // to the second.
        dx = cosa * 2.0 * D;
        dy = sina * 2.0 * D;
        
        // Calculate the new reflected point.
        x2 = x1 - dx; 
        y2 = y1 - dy;
        
        // Save the new point.
        To->X[i] = x2;
        To->Y[i] = y2;
    }
}

/*------------------------------------------------------------
| TestLineConversions
|-------------------------------------------------------------
|
| PURPOSE: To test the line conversion functions. 
|
| DESCRIPTION:  
|
| EXAMPLE:  
|
| NOTE: 
|
| ASSUMES: 
|           
| HISTORY: 04.05.96
|          04.06.96 Tested OK. 
------------------------------------------------------------*/
#if 0
void
TestLineConversions()
{
    f64     i;
    HessianLine h, k;
    General2DLine g;
    PointSlope  s,z;

    for( i = 0; i <= twopi; i += piby16 )
    {
        h.a = i;
        h.r = 2.0;
        printf( "\n\n");
        printf( "1. Input  a,r: %f,%f\n", h.a, h.r );
        
        HessianLineToGeneralLine( &h, &g );
        printf( "2. Output A,B,C: %f,%f,%f\n", 
                g.A, g.B, g.C );
        GeneralLineToHessianLine( &g, &k ); 
        printf( "3. Output a,r: %f,%f\n\n", k.a, k.r );
        
        ValidateSamePolarPoint( (RA*) &h, (RA*) &k );

        if( Chop(sin(i)) != 0 ) // not a vertical line.
        {
            HessianLineToPointSlope( &h, &s );
            printf( "3. b,m output is %f,%f\n", s.b, s.m );
            PointSlopeToGeneralLine( &s,  &g );
            printf( "4. Output A,B,C: %f,%f,%f\n", 
                        g.A, g.B, g.C );
            GeneralLineToPointSlope( &g,  &z ); 
            printf( "5. b,m output is %f,%f\n", z.b,z.m );
            PointSlopeToHessianLine( &z, &k ); 
            printf( "6. Output a,d: %f,%f\n\n", k.a, k.r );
            ValidateSamePolarPoint( (RA*) &h, (RA*) &k );

            HessianLineToGeneralLine( &h, &g );
            GeneralLineToPointSlope( &g, &s ); 
            PointSlopeToGeneralLine( &s,  &g );
            GeneralLineToHessianLine( &g,  &k ); 
            printf( "7. Output a,d: %f,%f\n\n", k.a, k.r );
            ValidateSamePolarPoint( (RA*) &h, (RA*) &k );
        }
    }
    
    printf( "Finished 'TestLineConversions'\n");
}
#endif 
#if 0
/*------------------------------------------------------------
| TestReflectVectorAboutLine
|-------------------------------------------------------------
|
| PURPOSE: To test the function 'ReflectVectorAboutLine'. 
|
| DESCRIPTION:  
|
| EXAMPLE:  
|
| NOTE: 
|
| ASSUMES: 
|           
| HISTORY: 04.02.96 Tested OK.
------------------------------------------------------------*/
void
TestReflectVectorAboutLine()
{
    f64     d,a,sina,cosa,xn,yn,le,de,ue;
    s32         i;
    f64     x[] = { -5, -2, 0, 2, 5 };
    f64     y[] = { -5, -2, 0, 2, 5 };
    Vector*     From;
    Vector*     To;
    Vector*     ALine;
    Vector*     dLine;
    DataSeries* FromSeries;
    DataSeries* ToSeries;
    LineGraph*  AGraph;
    f64     piover2;
    HessianLine h;
    
    piover2 = pi/2.0;
    
    AGraph = MakeGraph( "Press Button To Continue",
                        &DefaultGraphRect );
                       
//  From  = MakeVector( 5, x, y );
//  To    = MakeVector( 5, x, y );
    From = LoadClosingPrice( "NG96Z" );
    NormalizeVector( From );
    To    = DuplicateVector( From );
    
    ALine = MakeVector( 2, 0, 0 );
    dLine = MakeVector( 2, 0, 0 );
    
    FromSeries = AddPointsToGraph( AGraph, From, &Green );
    FromSeries->PointRadius = 1.0;
    
    ToSeries = AddPointsToGraph( AGraph, To, &Red );
    ToSeries->PointRadius = 1.0;
    
    AddLinesToGraph( AGraph, ALine, &Black );
    AddLinesToGraph( AGraph, dLine, &Black );
     
    d = 1.0; // Distance to the reflecting line.
    
    // Rotate the reflecting line around the axis.
    for( a = 0.0; a < twopi; a += piby16 )
    {
        h.r = d;
        h.a = a;
        
        sina = sin(a);
        cosa = cos(a);
        
        // Normal point on the reflecting line.
        xn = cosa * d;
        yn = sina * d;
        
        // Line from origin to normal point.
        dLine->X[0] = 0;
        dLine->Y[0] = 0;

        dLine->X[1] = xn;
        dLine->Y[1] = yn;
        
        // Calculate the line endpoints for the graph.
        
        // Distance from the origin to the endpoints
        de = d / cos( piby4 );
        
        // Angle of lower endpoint.
        le = a - (piby4);
        
        // Angle of upper endpoint.
        ue = a + (piby4);
        
        ALine->X[0] = cos(le) * de; 
        ALine->Y[0] = sin(le) * de; 

        ALine->X[1] = cos(ue) * de;
        ALine->Y[1] = sin(ue) * de;
        
        ReflectVectorAboutLine( &h, From, To );
        
        AutoScaleLineGraphSquare( AGraph );
        DrawGraph( AGraph );
        
        while(!Button());
        for(i=0;i<5000000;i++); // delay
    }
    
    DeleteGraph( AGraph );
    free( From );
    free( To );
    free( ALine );

}
#endif

/*------------------------------------------------------------
| TwoPointLineToGeneralLine
|-------------------------------------------------------------
|
| PURPOSE: To find the general equation for a line given
|          two points on that line.
|
| DESCRIPTION: 
|
| The two-point equation for a line is:
|
|       (y - y1)      (x - x1)
|      ----------- = -----------
|       (y2 - y1)     (x2 - x1)
|
|
|      solving for y:
|    
|                (y1 - y2) * x + x1 * y2 - x2 * y1
|           y = -----------------------------------
|                            x1 - x2 
|
|           if x == 0 then, the y intercept is
|
|                x1 * y2 - x2 * y1
|           y = ------------------- 
|                      x1 - x2 
|
|      solving for x:
|    
|                (x1 - x2) * y - x1 * y2 + x2 * y1
|           x = -----------------------------------
|                            y1 - y2 
|
|           if y == 0 then, the x intercept is
|
|                -(x1 * y2 + x2 * y1)
|           x = ----------------------
|                      y1 - y2 
|
| The general line equation is:
|
|      A * x + B * y + C = 0 
|
|
| EXAMPLE:  
|
| NOTE: From p. 199 of 'Handbook of Mathematics' by
|       Bronshtein and Semendyayev.
|
| ASSUMES: 
|           
| HISTORY: 04.04.96 
------------------------------------------------------------*/
void 
TwoPointLineToGeneralLine( TwoPoints* t, General2DLine* g )
{   
    f64 b, m;
    f64 x1, y1, x2, y2;

    // Unpack the two points.
    x1 = t->a.x;
    y1 = t->a.y;
    x2 = t->b.x;
    y2 = t->b.y;

    // Test for degenerate line, p1 == p2.
    if( x1 == x2 && y1 == y2 )
    {
        g->A = g->B = g->C = 0; 
                          // Invalid input so just return
                          // a reference to the origin.
        Debugger(); 
        return;
    }
    
    // Test for a vertical line.
    if( x1 == x2 )
    {
        // This is a vertical line, Ax + C = 0.
        // Solving for A,  A = -C/x, in this case x is
        // equal to x1. Set C to 1.0.
        g->C = 1.0;
        g->A = -( 1.0 / x1 );
        g->B = 0;
    }
    else // Not a vertical line.
    {
        // Calculate the slope.
        m = (y2 - y1) / (x2 - x1);
        
        // Calculate the y intercept.
        b = (x1 * y2 - x2 * y1) / (x1 - x2);
        
        // Point slope form can can be put into general
        // form by rearranging the terms,
        //
        //       y = mx + b,
        //
        //       mx - y + b = 0
        //
        //       Ax + By + C = 0
        //
        g->A = m;
        g->B = -1.0;
        g->C = b;
    }
}

