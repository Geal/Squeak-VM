/*------------------------------------------------------------
| TLModes.c
|-------------------------------------------------------------
|
| PURPOSE: To provide general operating mode functions.
|
| DESCRIPTION: 
|
| NOTE: 
|
| HISTORY: 01.28.94 
------------------------------------------------------------*/

#include "TLTarget.h"

#ifdef FOR_MACOS

#include <stdio.h>
#include <stdlib.h>

#include <Dialogs.h>
#include <OpenTptInternet.h>
#include <AppleEvents.h>

#include "TLTypes.h"
#include "TLBuf.h"
#include "TLMemHM.h"
#include "TLStacks.h"
#include "TLAscii.h"
#include "TLList.h"

// Include these for network applications.
#ifdef IS_NETWORK_AWARE
#include "TLNetAccess.h"
#include "TLNetIdle.h"
#endif

#include "TLWin.h"
#include "TLLog.h"
#include "TLModes.h"

u32     IsEndOfEventLoop;
        // When true, the event loop terminates.

u32     IsEvent;
        // 1 if there is a valid event in the event
        // buffer and variables.

u32     IsInForegroundMode = 1;
        // 1 if this application is active, 0 if some
        // other application is active.
         
u32     IsKeyDown;
        // 1 if a Keydown or AutoKey event just occurred, 
        // 0 otherwise.

u32     IsSys7SimulatedEvent;
        // When true, the event is a simulated user action
        // generated by Sys7.

u32     IsWaitNextEventAvailable;
        // If the WaitNextEvent feature is available,
        // this will be non-zero.
        
u32     TheMode;
        // The current operating mode.

s32     TheModeStartTime;
        // When the current operating mode started in 
        // ticks from when the computer turned on.
        // A 'tick' is a sixtieth of a second.
        // From the system variable 'Ticks'.

u32     LastButton;
        // Button ID of the last button activated by user.
        
s32     TheMenuResult;
        // The menu result code for the last selected menu item
        // or command key equivalent.

s16     TheMenuItem;
        // The item ID number for the last selected menu item
        // or command key equivalent.

s16     TheMenuID;
        // The menu ID code for the last selected menu item
        // or command key equivalent.
         
// This stack holds the ModeIDs of suspended modes. 

Stack*  TheModeStack;

// This stack holds suspended events.

Stack*  TheEventStack;

AnyProcedure    TheCycleInterpreter;
                // Holds the address of the current procedure
                // used to process tasks on each pass
                // through the event loop.

AnyProcedure    TheMenuUpdateProcedure=DoNothing;
                // Holds the address of the current procedure
                // used to update the menus when they are
                // picked.

AnyProcedure*   TheEventTable;
                // Holds the address of the current event
                // table used to interpret events in the 
                // current operating context on each pass 
                // through the event loop.
                 
// This is where all events go as they come in.
EventRecord TheEvent;

// Global variables used to hold the most recent event.
// This mainly for ease of reference and speed.

Point   TheMouseLocation;
s16     TheMouseX;
s16     TheMouseY;
s16     TheEventModifiers;
s16     TheEventType;
s32     TheEventMessage;
s32     TheEventTime;
s8      TheKey;


WindowPtr       TheEventWindow;
                // Window containing the event, OS-specific
                
Window*         TheEventWindowOSGeneric;
                // Window containing the event, OS-generic.
                
s16             TheWindowPart;
                // The part of the window where the event
                // occurred.

ControlHandle   TheControl;
                // The control at the mouse.

s16             TheControlPart;
                // The part of the control where the event
                // occurred.

s16             TheDialogItemHit;
                // This is the item number of the last
                // dialog item selected.

u32             IsInDialog;
                // 1 if the last button down was in
                // a dialog window.
                     
u32             IsDialogItemHit;
                // 1 if the last button down hit an
                // enabled dialog item.
                     
u32             IsInMenuBar;
                // 1 if the last button down was in
                // the menu bar.

u32             IsCommandKey;
                // 1 if the last key down was a
                // command key.
                     
// The mode table is defined in the application mode file.

/*------------------------------------------------------------
| ChangeToMode
|-------------------------------------------------------------
|
| PURPOSE: To change from the current mode of operation to
|          a new given mode.
|
| DESCRIPTION:
|
| EXAMPLE:  ChangeToMode(InstalledTitleMode);
|
| NOTE: 
|
| ASSUMES:  
|
| HISTORY: 01.28.94 
|
------------------------------------------------------------*/
void
ChangeToMode(u32 NewMode) 
{
    ExitMode();
    EnterMode(NewMode);
}

/*------------------------------------------------------------
| CleanUpModeSystem
|-------------------------------------------------------------
|
| PURPOSE: To clean up the mode system.
|
| DESCRIPTION:
|
| EXAMPLE:  CleanUpModeSystem();
|
| NOTE: 
|
| ASSUMES:  
|
| HISTORY: 01.28.94 
|
------------------------------------------------------------*/
void
CleanUpModeSystem()
{
    free( (u8*) TheModeStack );
    TheModeStack = 0;
    
    free( (u8*) TheEventStack );
    TheEventStack = 0;
}

/*------------------------------------------------------------
| DoDebugExit
|-------------------------------------------------------------
|
| PURPOSE: To be a procedure that can be called via an event
|          to halt in the debugger just before exiting.
|
| DESCRIPTION:
|
| EXAMPLE:  DoDebugExit();
|
| NOTE: 
|
| ASSUMES:  
|
| HISTORY: 01.28.94 
|          08.28.98 Renamed from 'DoKeyQuit()'.
------------------------------------------------------------*/
void 
DoDebugExit() 
{ 
    Debugger();
    ExitToShell(); 
} 

/*------------------------------------------------------------
| DoHighLevelEvent
|-------------------------------------------------------------
|
| PURPOSE: To interpret a high-level event, including Apple
|          Events.
|
| DESCRIPTION:
|
|   Responds only to 'kHighLevelEvent' events, #23, sent by 
|   MacOS or other applications.
|
|   Apple events and other high-level events are identified
|   by a message class of 'kHighLevelEvent' in the 'what'
|   field of the event record.
|
|   High-level events are only received if the 
|   'isHighLevelEventAware' flag is set in the application's 
|   SIZE resource.
|
|   The 'localAndRemoteHLEvents' flag must be set in the 
|   application's SIZE resource to receive high-level events
|   sent from another computer on the network.  For this to
|   work the user must enable program linking in the File
|   Sharing control panel.
|
| EXAMPLE:  
|
| NOTE: 
|
| ASSUMES: 
|
| HISTORY: 08.23.98
------------------------------------------------------------*/
void
DoHighLevelEvent()
{
    OSErr   err;

    // Application-specific high-level event handling
    // should be done here before calling 
    // 'AEProcessAppleEvent'.
    //
    // DoAppSpecificHighLevelEvent( &TheEvent );
    
    err = AEProcessAppleEvent( &TheEvent );
    
    // Application-specific error handling goes here.
    //
    // DoAppSpecificResponseToAppleEventError( &TheEvent );
}

/*------------------------------------------------------------
| DoNothing
|-------------------------------------------------------------
|
| PURPOSE: To provide a placeholder for procedure vectors.
|
| DESCRIPTION:
|
| EXAMPLE:  DoNothing();
|
| NOTE: 
|
| ASSUMES:  
|
| HISTORY: 01.28.94 
|
------------------------------------------------------------*/
void
DoNothing()
{
}

/*------------------------------------------------------------
| EnterMode
|-------------------------------------------------------------
|
| PURPOSE: To enter a mode.
|
| DESCRIPTION: Sets up the event and context interpreters
| for the mode and marks 'TheMode' to identify the current
| mode.
|
| EXAMPLE:  EnterMode(DemoTitleMode);
|
| NOTE: Use 'ChangeToMode' when current mode should be
|       cleaned up.
|
| ASSUMES:  
|
| HISTORY: 01.28.94 
|          01.31.94 pulled out 'TheEventInterpreter' in favor
|                   of 'TheEventTable'
|          02.03.94 added 'TheModeStartTime'
------------------------------------------------------------*/
void
EnterMode( u32 NewMode ) 
{
    TheMode = NewMode;
    
    TheModeStartTime = (s32) TickCount();
    
    TheCycleInterpreter = 
        TheModeTable[TheMode].DoModeCyclic;
    
    TheEventTable = (AnyProcedure *)
        TheModeTable[TheMode].ModeEventTable;

    (*TheModeTable[TheMode].DoEnterMode)();
}

/*------------------------------------------------------------
| EnterSubMode
|-------------------------------------------------------------
|
| PURPOSE: To suspend the current mode and enter a sub-ordinate
|          mode.
|
| DESCRIPTION:
|
| EXAMPLE:  EnterSubMode(TourPauseMode);
|
| NOTE: 
|
| ASSUMES:  
|
| HISTORY: 01.28.94 
|
------------------------------------------------------------*/
void
EnterSubMode(u32 NewMode)
{
    SuspendMode();
    EnterMode(NewMode);
}

/*------------------------------------------------------------
| ExitMode
|-------------------------------------------------------------
|
| PURPOSE: To exit the current mode.
|
| DESCRIPTION:
|
| EXAMPLE:  ExitMode();
|
| NOTE: 
|
| ASSUMES:  
|
| HISTORY: 01.28.94 
|          12.06.96 added cyclic function shutdown.
------------------------------------------------------------*/
void
ExitMode()
{
    // Disable the cyclic functions before exiting the mode.
    TheCycleInterpreter = DoNothing;

    (*TheModeTable[TheMode].DoExitMode)();
}   

/*------------------------------------------------------------
| ExitSubMode
|-------------------------------------------------------------
|
| PURPOSE: To exit the current mode to the mode that called
|          it.
|
| DESCRIPTION:
|
| EXAMPLE:  ExitSubMode();
|
| NOTE: 
|
| ASSUMES:  
|
| HISTORY: 01.28.94 
|
------------------------------------------------------------*/
void
ExitSubMode()
{
    ExitMode();
    ResumeMode();
}

/*------------------------------------------------------------
| GetModeAge
|-------------------------------------------------------------
|
| PURPOSE: To get the age of the current mode, in ticks.
|
| DESCRIPTION: Returns the number of ticks since the mode
|              was entered.
|
| EXAMPLE:   
|
| NOTE: 
|
| ASSUMES:  
|
| HISTORY: 02.03.94 
|
------------------------------------------------------------*/
s32
GetModeAge()
{
    return( (s32) TickCount() - TheModeStartTime);
}

/*------------------------------------------------------------
| GetPendingEvent 
|-------------------------------------------------------------
|
| PURPOSE: To get any pending event and pass control to 
|          system for background processing.
|
| DESCRIPTION: Sets 'IsEvent' to '1' if an event was 
| fetched.  Handles pre-System 7 and System 7.  Sets the
| event-related variables.
|
| EXAMPLE:  GetPendingEvent();
|
| NOTE:  
|
| ASSUMES: The environment has been identified and 
|          'IsWaitNextEventAvailable' set properly.
|
| HISTORY: 02.12.94 
|          02.24.94 added IsSys7SimulatedEvent
------------------------------------------------------------*/
void
GetPendingEvent()
{
    Point   AtMouse;
    s16     dV;
    s16     dH;
    
    //
    // Fetch next event.
    //
    if( IsWaitNextEventAvailable )
    { // Multifinder
        IsEvent = WaitNextEvent(
                      everyEvent,   // Enable all events.
                      &TheEvent,
                      WaitNextEventSleepTime, 
                      (u32) 0);     // No mouse region handle.
    }
    else // NonMultifinder
    {
            // Update desk accessories.
        SystemTask();
        
            // mask: allow only 12 events.
        IsEvent = GetNextEvent( 0x0FFF, &TheEvent );
    }
    
    // Put the event fields into global variables for speed and
    // ease of reference.
    //
    TheEventType      = TheEvent.what;
    TheEventMessage   = TheEvent.message;
    TheEventTime      = (s32) TheEvent.when;
                        // When event generated in ticks,
                        // 60th of second from startup. 
                     
    TheMouseX         = TheEvent.where.h;  // Where the mouse is.
    TheMouseY         = TheEvent.where.v;
    TheMouseLocation  = TheEvent.where;
    
    TheEventModifiers = TheEvent.modifiers;
    
    // Detect simulated System 7 events like selecting the 'Quit' 
    // from the 'File' menu.
    //
    // THIS MAY BE OBSOLETE: Reconsider simulated events.
    IsSys7SimulatedEvent = 0;
    
    if( TheEventType == mouseDown )
    {
        GetMouse( &AtMouse );
        
        dV = TheMouseY - (s16) AtMouse.v;
        if( dV < 0) dV = -dV;
        
        dH = TheMouseX - AtMouse.h;
        if( dH < 0) dH = -dH;
        
        if( dH > 10 || dV > 10 )
        {
            IsSys7SimulatedEvent = 1;
        }
    }
}

/*------------------------------------------------------------
| PreProcessDialogEvent
|-------------------------------------------------------------
|
| PURPOSE: To do work required for all dialog events.
|
| DESCRIPTION: Sets the variables, 'IsDialogItemHit',
| 'IsInDialog', 'TheDialogItemHit'.  Blinks cursor in text
| entry fields for dialogs and handles some text editing.
|
| EXAMPLE:  PreProcessDialogEvent();
|
| NOTE:  
|
| ASSUMES: Follows 'PreProcessKeyEvent'.
|
| HISTORY: 02.12.94 
------------------------------------------------------------*/
void
PreProcessDialogEvent()
{
    IsDialogItemHit = 0;
    IsInDialog      = 0;
    
    // Even if 'IsEvent' is 0, a call needs to be made
    // to 'IsDialogEvent' and then 'DialogSelect' in order 
    // for the text cursor to blink in modeless dialogs. 
    // See p. I-416 of Inside Mac.
    //
    IsInDialog = (u32) IsDialogEvent( &TheEvent );
        
    if( IsInDialog )
    { 
        if(IsKeyDown && 
           (IsCommandKey || 
            TheKey == EnterKey || 
            TheKey == CarriageReturn) 
          )
        { // Don't pass control keys to the dialog. This 
          // limits dialog text input to a single line.
          //
        }
        else // Call DialogSelect for everything else.
        {
            IsDialogItemHit = (u32)
                DialogSelect( &TheEvent,
                              &TheEventWindow,
                              &TheDialogItemHit );
        }
    } 
}

/*------------------------------------------------------------
| PreProcessKeyEvent
|-------------------------------------------------------------
|
| PURPOSE: To do work required for all keyboard events.
|
| DESCRIPTION: Sets the variables, 'IsKeyDown',
| 'IsCommandKey', 'TheKey'.  Updates menus if a command
| key was pressed and sets 'TheMenuResult'.
|
| EXAMPLE:  PreProcessKeyEvent();
|
| NOTE:  
|
| ASSUMES:  
|
| HISTORY: 02.12.94 
|          06.10.94 added return if no event.
------------------------------------------------------------*/
void
PreProcessKeyEvent()
{
    IsKeyDown       = 0;
    IsCommandKey    = 0;

    if( IsEvent == 0 ) 
    {
        return;
    }

    // Fetch key down event info.
    if( TheEventType == keyDown ||
        TheEventType == autoKey ) 
    {
        IsKeyDown = 1;
        
        TheKey = TheEventMessage & charCodeMask;
            
        if( TheEventModifiers & cmdKey ) 
        {
            UpdateMenus();
            
            IsCommandKey = 1;
                
            TheMenuResult = MenuKey(TheKey);
        }
    }
}

/*------------------------------------------------------------
| PullEvent
|-------------------------------------------------------------
|
| PURPOSE: To restore an event preserved on TheEventStack.
|
| DESCRIPTION: In some cases simulated events are generated
| in the course of processing an event and so the parent
| event needs to be restored after processing the offspring.
|
|
| EXAMPLE:  PushEvent();
|           <do something>
|           PullEvent();
|
| NOTE:  
|
| ASSUMES: 
|
| HISTORY: 02.04.94  
|          06.03.94 added 'IsEvent'
|          09.12.98 Added 'TheEventWindowOSGeneric'.
------------------------------------------------------------*/
void
PullEvent()
{
    TheEventTime            = (s32)       Pull( TheEventStack );
    TheEventModifiers       = (s16)       Pull( TheEventStack );
    TheEventWindowOSGeneric = (Window*)   Pull( TheEventStack );
    TheEventWindow          = (WindowPtr) Pull( TheEventStack );
    TheEventMessage         = (s32)       Pull( TheEventStack );
    TheEventType            = (s16)       Pull( TheEventStack );
    IsEvent                 = (u32)       Pull( TheEventStack );

    TheEvent.what           = TheEventType;
    TheEvent.when           = TheEventTime;
    TheEvent.message        = TheEventMessage;
    TheEvent.modifiers      = TheEventModifiers;
}

/*------------------------------------------------------------
| PushEvent
|-------------------------------------------------------------
|
| PURPOSE: To preserve the current event on TheEventStack.
|
| DESCRIPTION: In some cases simulated events are generated
| in the course of processing an event and so the parent
| event needs to be preserved while processing the offspring.
|
|
| EXAMPLE:  PushEvent();
|           <do something>
|           PullEvent();
|
| NOTE:  
|
| ASSUMES: The mouse location doesn't need to be preserved.
|
| HISTORY: 02.04.94  
|          06.03.94 added 'IsEvent'.
|          09.12.98 Added 'TheEventWindowOSGeneric'.
------------------------------------------------------------*/
void
PushEvent()
{
    Push( TheEventStack, (u32) IsEvent );
    Push( TheEventStack, (u32) TheEventType );
    Push( TheEventStack, (u32) TheEventMessage );
    Push( TheEventStack, (u32) TheEventWindow );
    Push( TheEventStack, (u32) TheEventWindowOSGeneric );
    Push( TheEventStack, (u32) TheEventModifiers );
    Push( TheEventStack, (u32) TheEventTime );
}

/*------------------------------------------------------------
| ResumeMode
|-------------------------------------------------------------
|
| PURPOSE: To resume a mode that was previously suspended.
|
| DESCRIPTION:
|
| EXAMPLE:  ResumeMode();
|
| NOTE: 
|
| ASSUMES:  
|
| HISTORY: 01.28.94 
|          02.03.94 added 'TheModeStartTime'
|
------------------------------------------------------------*/
void
ResumeMode()
{
    TheModeStartTime = (s32) Pull(TheModeStack);
    
    TheMode = Pull(TheModeStack);
    
    TheCycleInterpreter = 
        TheModeTable[TheMode].DoModeCyclic;
    
    TheEventTable = (AnyProcedure *)
        TheModeTable[TheMode].ModeEventTable;

    (*TheModeTable[TheMode].DoResumeMode)();
}

/*------------------------------------------------------------
| SetUpModeSystem
|-------------------------------------------------------------
|
| PURPOSE: To set up the mode system.
|
| DESCRIPTION:
|
| EXAMPLE:  SetUpModeSystem();
|
| NOTE: 
|
| ASSUMES: Will only be called once.
|
| HISTORY: 01.28.94 
|          01.09.97 added 'IsEndOfEventLoop' clearing so that
|                   pending events can be processed.
------------------------------------------------------------*/
void
SetUpModeSystem()
{
    TheModeStack  = MakeStack( (u32) MaxModeDepth );
    TheEventStack = MakeStack( (u32) MaxEventDepth );
    
    IsEndOfEventLoop = 0;
}

/*------------------------------------------------------------
| SimulateActivateEvent
|-------------------------------------------------------------
|
| PURPOSE: To simulate an activate event.
|
| DESCRIPTION: 
|
| EXAMPLE:  SimulateActivateEvent( TheEventWindow );
|
| NOTE:  
|
| ASSUMES: The mouse location stays the same as the last
|          event.
|
| HISTORY: 02.04.94 
|          06.03.94 added 'IsEvent'
|          09.12.98 Added 'TheEventWindowOSGeneric'.
------------------------------------------------------------*/
void
SimulateActivateEvent( WindowPtr AWindow ) 
{
    PushEvent();
    
    IsEvent            = 1;
    
    TheEvent.what      = activateEvt;
    TheEvent.when      = TickCount();
    TheEvent.message   = (s32) AWindow;
    TheEvent.modifiers = activeFlag;

    TheEventType      = TheEvent.what;
    TheEventMessage   = TheEvent.message;
    TheEventTime      = TheEvent.when;     // When event generated in ticks,
                                           // 60th of second from startup. 
                                           //
    TheEventWindow    = AWindow;
    
    // Find the OS-generic window record that corresponds to 
    // the OS-specific window, if any.
    TheEventWindowOSGeneric = FindOSGenericWindow( AWindow );
 
    TheEventModifiers = TheEvent.modifiers;
            
    // Process the event.
    (*TheEventTable[TheEventType])();
            
    PullEvent();
}
        
/*------------------------------------------------------------
| SimulateDeactivateEvent
|-------------------------------------------------------------
|
| PURPOSE: To simulate a deactivate event.
|
| DESCRIPTION: 
|
| EXAMPLE:  SimulateDeactivateEvent( TheEventWindow );
|
| NOTE:  
|
| ASSUMES: The mouse location stays the same as the last
|          event.
|
| HISTORY: 02.04.94 
|          09.12.98 Added 'TheEventWindowOSGeneric'.
------------------------------------------------------------*/
void
SimulateDeactivateEvent( WindowPtr AWindow )
{
    PushEvent();
    
    IsEvent            = 1;
    
    TheEvent.what      = activateEvt;
    TheEvent.when      = TickCount();
    TheEvent.message   = (s32) AWindow;
    TheEvent.modifiers = 0; // A deactivate

    TheEventType      = TheEvent.what;
    TheEventMessage   = TheEvent.message;
    TheEventTime      = TheEvent.when;     // When event generated in ticks,
                                           // 60th of second from startup. 
                                           //
    TheEventWindow    = AWindow;
    
    // Find the OS-generic window record that corresponds to 
    // the OS-specific window, if any.
    TheEventWindowOSGeneric = FindOSGenericWindow( AWindow );
    
    TheEventModifiers = TheEvent.modifiers;
            
    // Process the event.
    (*TheEventTable[TheEventType])();
            
    PullEvent();
}

/*------------------------------------------------------------
| SimulateKeyDownEvent
|-------------------------------------------------------------
|
| PURPOSE: To simulate a key down event.
|
| DESCRIPTION: Expects the ascii value of the key in the low
| byte of 'KeyCode'; the high byte normally holds the key 
| code but this is ignored.  
|
| The 'KeyModifier' is encoded as follows:
|            12 11 10 9 8
|        - - - 1 1 1 1 1 - - - - - - - -
|               \ \ \ \ \___Command key down,   'cmdKey'
|                \ \ \ \____Shift key down,     'shiftKey'
|                 \ \ \_____Caps lock key down, 'alphaLock'
|                  \ \______Option key down,    'optionKey'
|                   \_______Control key down,   'controlKey'
|           
| EXAMPLE:  SimulateKeyDownEvent('A',0);
|           SimulateKeyDownEvent('S',cmdKey);
|
| NOTE: See p. 32 of 'Using the Macintosh Toolbox in C'.
|
| ASSUMES: The mouse location stays the same as the last
|          event.
|
| HISTORY: 06.03.94  
------------------------------------------------------------*/
void
SimulateKeyDownEvent( u16 KeyCode, u16 KeyModifier )
{
    PushEvent();
    
    IsEvent            = 1;
    
    TheEvent.what      = keyDown;
    TheEvent.when      = TickCount();
    TheEvent.message   = (s32) KeyCode;
    TheEvent.modifiers = KeyModifier;  

    TheEventType      = TheEvent.what;
    TheEventMessage   = TheEvent.message;
    TheEventTime      = TheEvent.when;     
    // When event generated in ticks,
    // 60th of second from startup. 
    //
     
    TheEventModifiers = TheEvent.modifiers;

    PreProcessKeyEvent();
            
    // Process the event.
    (*TheEventTable[TheEventType])();
            
    PullEvent();
}

/*------------------------------------------------------------
| SuspendMode
|-------------------------------------------------------------
|
| PURPOSE: To suspend the current mode.
|
| DESCRIPTION:
|
| EXAMPLE:  SuspendMode();
|
| NOTE: 
|
| ASSUMES:  
|
| HISTORY: 01.28.94 
|          02.03.94 added 'TheModeStartTime'
|          12.06.96 added cyclic function suspension.
------------------------------------------------------------*/
void
SuspendMode()
{
    // Disable the mode's cyclic functions before suspending 
    // the mode.
    TheCycleInterpreter = DoNothing;
    
    (*TheModeTable[TheMode].DoSuspendMode)();
    
    Push(TheModeStack,TheMode);
    
    Push(TheModeStack,(u32) TheModeStartTime);
}

/*------------------------------------------------------------
| TheEventLoop
|-------------------------------------------------------------
|
| PURPOSE: To do the main operation loop.
|
| DESCRIPTION: Interprets the current operating context and
| any events that are received in that context.  If an event
| is received it is placed in 'TheEvent' and the global
| variables associated with 'TheEvent' are filled in.
|
| The current cycle interpreter is held in a variable 
| called 'TheCycleInterpreter'.
|
| The current event table is held in a variable called
| 'TheEventTable'.
|
| The context interpreter may alter the context of the above
| interpreter variables to shift contexts or operating modes.
|
| This procedure runs until the variable 'IsEndOfEventLoop'
| is set to 1.
|
| EXAMPLE:  TheEventLoop();
|
| NOTE:  
|
| ASSUMES: The interpreters have been set up.
|
| HISTORY: 01.28.94 
|          01.31.94 added 'TheEventTable'.
|          02.03.94 added dialog event info pre-fetch.
|                   added 'SystemClick'
|          02.07.94 moved 'IsDialogEvent' to follow
|                   Wait/GetNextEvent even if no event is
|                   detected.
|          02.12.94 factored sub-procedures
|          11.24.96 added 'NetIdle'.
|          12.11.96 added 'LogIdle'.
|                   Factored out 'ProcessPendingEvent'.
------------------------------------------------------------*/
void
TheEventLoop()
{ 
    IsEndOfEventLoop = 0;
    
AnotherEvent:

    if( IsEndOfEventLoop ) 
    {
        return;
    }

    ProcessPendingEvent();

goto AnotherEvent;

}

/*------------------------------------------------------------
| ProcessPendingEvent
|-------------------------------------------------------------
|
| PURPOSE: To handle an event in the queue.
|
| DESCRIPTION: Exactly the same as the event loop but also 
| returns on IsEvent == 0.  
|
| Used to process one event and pass control to other 
| applications via 'WaitNextEvent'.
|
| EXAMPLE:  ProcessPendingEvent();
|
| NOTE:  
|
| ASSUMES: Handles events the same was as 'TheEventLoop'.
|
| HISTORY: 11.25.96 from 'ProcessPendingEvents'.
|          12.11.96 added 'LogIdle'.
|          12.23.96 enabled mode cyclic processing when
|                   not in fore ground mode.
|          09.12.98 Added 'TheEventWindowOSGeneric'.
------------------------------------------------------------*/
void
ProcessPendingEvent()
{ 
    if( IsEndOfEventLoop ) 
    {
        return;
    }

#ifdef IS_NETWORK_AWARE
    // For network cyclic processing.
    NetIdle();
#endif
    
    // For application log output.
//  LogIdle();
    
    // Do the mode-dependent cyclic function.
    (*TheCycleInterpreter)();
    
    // Allow task switch and get any waiting event.
    GetPendingEvent();
    
    PreProcessKeyEvent();
    
    PreProcessDialogEvent();
    
    // If no event detected, then return.
    
    if( !IsEvent )
    {
        return; // This line is the only one different
                // from 'TheEventLoop'.
    }
    
    // Interpret the event.
    
    // Pre-fetch info needed for special events.
    
    // The event window is contained in the message
    // field for update and activate events.
    //
    if( TheEventType == activateEvt ||
        TheEventType == updateEvt )
    {
        TheEventWindow = (WindowPtr) TheEventMessage;
        
        // Find the OS-generic window record that corresponds to 
        // the OS-specific window, if any.
        TheEventWindowOSGeneric = FindOSGenericWindow( TheEventWindow );

        goto ProcessEvent;
    }

    if( TheEventType == mouseDown )
    {
        // Locate the window where the mouse cursor is.
        TheWindowPart = FindWindow( TheMouseLocation, &TheEventWindow );
        
        // If the mouse is not in any of the application windows.
        if( TheWindowPart == inSysWindow )
        { 
            // Pass the event to the OS for handling.
            SystemClick( &TheEvent, TheEventWindow );
            
            // Nothing else to do so just return.
            return;
        }

        // If click occurred in the menu bar get the selection.
        if( TheWindowPart == inMenuBar )
        {
            UpdateMenus();

            IsInMenuBar = 1;
            
            TheMenuResult = MenuSelect(TheMouseLocation);
        }
        else // Not in the menu bar.
        {
            IsInMenuBar = 0;
            
            // Find the OS-generic window record that corresponds to 
            // the OS-specific window, if any.
            TheEventWindowOSGeneric = FindOSGenericWindow( TheEventWindow );
        }
    }
    
ProcessEvent:   
    // Process the event.
    (*TheEventTable[TheEventType])();

    // Update menus following an update event. 
    //
    if( TheEventType == updateEvt )
    {
        UpdateMenus();
    }
}

/*------------------------------------------------------------
| ProcessPendingEventEverySecond
|-------------------------------------------------------------
|
| PURPOSE: To handle an event in the queue if a second has
|          passed since this function last handled an event.
|
| DESCRIPTION: Exactly the same as the event loop but also 
| returns on IsEvent == 0.  
|
| Used to process one event and pass control to other 
| applications via 'WaitNextEvent'.
|
| EXAMPLE:  ProcessPendingEventEverySecond();
|
| NOTE:  
|
| ASSUMES: Handles events the same was as 'TheEventLoop'.
|
| HISTORY: 06.30.97 from 'ProcessPendingEvent()'.
------------------------------------------------------------*/
void
ProcessPendingEventEverySecond()
{ 
    static u32  AfterTicks = 0;
    u32         CurrentTicks;
    
    CurrentTicks = TickCount();
    
    if( CurrentTicks > AfterTicks )
    {
        ProcessPendingEvent();
        
        AfterTicks = CurrentTicks + 60;
    }
}
    
/*------------------------------------------------------------
| ProcessPendingEvents
|-------------------------------------------------------------
|
| PURPOSE: To handle any events in the queue until there are
|          no more.
|
| DESCRIPTION: Exactly the same as the event loop but also 
| returns on IsEvent == 0.  Used to process 
| update/activate events generated following an action
| that generates those events.
|
| EXAMPLE:  ProcessPendingEvents();
|
| NOTE:  
|
| ASSUMES: Handles events the same was as 'TheEventLoop'.
|
| HISTORY: 02.11.94 
|          11.24.96 added 'NetIdle'.
|          12.11.96 replaced loop contents with 
|                   'ProcessPendingEvent'.
------------------------------------------------------------*/
void
ProcessPendingEvents()
{ 
AnotherEvent:

    if( IsEndOfEventLoop ) 
    {
        return;
    }

    ProcessPendingEvent();

    // If no event detected, then return.
    if( !IsEvent )
    {
        return; // This line is the only one different
                // from 'TheEventLoop'.
    }

goto AnotherEvent;
}

/*------------------------------------------------------------
| UpdateMenus
|-------------------------------------------------------------
|
| PURPOSE: To update the menu state.
|
| DESCRIPTION: Called after a menu selected but before
| and item is picked.  May also be called any other time
| to make menu bar current.  
|
| EXAMPLE:  UpdateMenus();
|
| NOTE:  
|
| ASSUMES: 'TheMenuUpdateProcedure' holds the address of
|          the procedure to execute.
|
| HISTORY: 02.12.94 
------------------------------------------------------------*/
void
UpdateMenus()
{
    (*TheMenuUpdateProcedure)();
}

#endif // FOR_MACOS
